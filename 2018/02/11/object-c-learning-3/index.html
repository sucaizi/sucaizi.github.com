<!-- build time:Sun Feb 11 2018 19:52:36 GMT+0800 (CST) --><!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>object-c 第三章 | future&#39;s blog</title><meta name="description" content="第三章 框架框架是构成支持所有Objective-C 开发的库的基础。其中包括提供了对诸如字符串，数组，字典，其他通用对象及其适配的方法的支持。框架比Cocoa库处于更低的抽象层次。Cocoa库和UIKit套件关心的应用程序，视图以及用户输入，而框架则关注组织数据的底层任务。在本章中，你将学习框架提供的一些重点类，以及了解Cocoa 和 Cocoa Touch 所依赖的设计模式。可变和不可变对象框"><meta name="keywords" content="object-c"><meta property="og:type" content="article"><meta property="og:title" content="object-c 第三章"><meta property="og:url" content="https://sucaizi.github.io/2018/02/11/object-c-learning-3/index.html"><meta property="og:site_name" content="future&#39;s blog"><meta property="og:description" content="第三章 框架框架是构成支持所有Objective-C 开发的库的基础。其中包括提供了对诸如字符串，数组，字典，其他通用对象及其适配的方法的支持。框架比Cocoa库处于更低的抽象层次。Cocoa库和UIKit套件关心的应用程序，视图以及用户输入，而框架则关注组织数据的底层任务。在本章中，你将学习框架提供的一些重点类，以及了解Cocoa 和 Cocoa Touch 所依赖的设计模式。可变和不可变对象框"><meta property="og:locale" content="zh"><meta property="og:updated_time" content="2018-02-11T11:52:20.571Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="object-c 第三章"><meta name="twitter:description" content="第三章 框架框架是构成支持所有Objective-C 开发的库的基础。其中包括提供了对诸如字符串，数组，字典，其他通用对象及其适配的方法的支持。框架比Cocoa库处于更低的抽象层次。Cocoa库和UIKit套件关心的应用程序，视图以及用户输入，而框架则关注组织数据的底层任务。在本章中，你将学习框架提供的一些重点类，以及了解Cocoa 和 Cocoa Touch 所依赖的设计模式。可变和不可变对象框"><link rel="canonical" href="https://sucaizi.github.io/2018/02/11/object-c-learning-3/index.html"><link rel="alternate" href="/atom.xml" title="future&#39;s blog" type="application/atom+xml"><link rel="icon" href="/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"></head><body class="main-center theme-blue" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="https://github.com/sucaizi" target="_blank"><img class="img-circle img-rotate" src="https://avatars1.githubusercontent.com/u/1609965?s=460&amp;v=4" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">future</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md">Web Developer &amp; Java Developer</h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> GuangZhou, China</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="Search"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="Type something..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">Home</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">Archives</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">Categories</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">Tags</span></a></li><li class="menu-item menu-item-repository"><a href="/repository"><i class="icon icon-project"></i> <span class="menu-title">Repository</span></a></li><li class="menu-item menu-item-books"><a href="/books"><i class="icon icon-book-fill"></i> <span class="menu-title">Books</span></a></li><li class="menu-item menu-item-links"><a href="/links"><i class="icon icon-friendship"></i> <span class="menu-title">Links</span></a></li><li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span class="menu-title">About</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/sucaizi" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">Board</h3><div class="widget-body"><div id="board"><p>您好，您是第<span id="busuanzi_value_site_uv">0</span>位访客</p><div class="content"><p>欢迎交流与分享经验!</p></div></div></div></div><div class="widget"><h3 class="widget-title">Categories</h3><div class="widget-body"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nodejs/">nodejs</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习/">学习</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/思考与总结/">思考与总结</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书/">读书</a><span class="category-list-count">2</span></li></ul></div></div><div class="widget"><h3 class="widget-title">Tags</h3><div class="widget-body"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-web/">java web</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/">nodejs</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/object-c/">object-c</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编程有法/">编程有法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书/">读书</a><span class="tag-list-count">2</span></li></ul></div></div><div class="widget"><h3 class="widget-title">Tag Cloud</h3><div class="widget-body tagcloud"><a href="/tags/java-web/" style="font-size:13.67px">java web</a> <a href="/tags/nodejs/" style="font-size:13px">nodejs</a> <a href="/tags/object-c/" style="font-size:14px">object-c</a> <a href="/tags/编程有法/" style="font-size:13px">编程有法</a> <a href="/tags/读书/" style="font-size:13.33px">读书</a></div></div><div class="widget"><h3 class="widget-title">Archive</h3><div class="widget-body"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">Recent Posts</h3><div class="widget-body"><ul class="recent-post-list list-unstyled no-thumbnail"><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/学习/">学习</a></p><p class="item-title"><a href="/2018/02/11/object-c-learning-5/" class="title">object-c 第五章</a></p><p class="item-date"><time datetime="2018-02-11T11:45:32.000Z" itemprop="datePublished">2018-02-11</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/学习/">学习</a></p><p class="item-title"><a href="/2018/02/11/object-c-learning-4/" class="title">object-c 第四章</a></p><p class="item-date"><time datetime="2018-02-11T11:45:29.000Z" itemprop="datePublished">2018-02-11</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/学习/">学习</a></p><p class="item-title"><a href="/2018/02/11/object-c-learning-3/" class="title">object-c 第三章</a></p><p class="item-date"><time datetime="2018-02-11T11:45:25.000Z" itemprop="datePublished">2018-02-11</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/学习/">学习</a></p><p class="item-title"><a href="/2018/02/11/object-c-learning-2/" class="title">object-c 第二章</a></p><p class="item-date"><time datetime="2018-02-11T11:44:41.000Z" itemprop="datePublished">2018-02-11</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/学习/">学习</a></p><p class="item-title"><a href="/2018/02/11/object-c-learning-1/" class="title">object-c 第一章</a></p><p class="item-date"><time datetime="2018-02-11T11:42:16.000Z" itemprop="datePublished">2018-02-11</time></p></div></li></ul></div></div></div></aside><aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><nav id="toc" class="article-toc"><h3 class="toc-title">Catalogue</h3><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第三章-框架"><span class="toc-number">1.</span> <span class="toc-text">第三章 框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#可变和不可变对象"><span class="toc-number">1.0.1.</span> <span class="toc-text">可变和不可变对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串"><span class="toc-number">1.0.2.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串的创建"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">字符串的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串的使用"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">字符串的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#大小写和路径"><span class="toc-number">1.0.2.2.1.</span> <span class="toc-text">大小写和路径</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#查找子符"><span class="toc-number">1.0.2.2.2.</span> <span class="toc-text">查找子符</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#比较字符串"><span class="toc-number">1.0.2.3.</span> <span class="toc-text">比较字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#搜索字符串"><span class="toc-number">1.0.2.4.</span> <span class="toc-text">搜索字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组"><span class="toc-number">1.0.3.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快速列举"><span class="toc-number">1.0.4.</span> <span class="toc-text">快速列举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可变数组"><span class="toc-number">1.0.5.</span> <span class="toc-text">可变数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字典"><span class="toc-number">1.0.6.</span> <span class="toc-text">字典</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSValue-和NSNumber"><span class="toc-number">1.0.7.</span> <span class="toc-text">NSValue 和NSNumber</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSData"><span class="toc-number">1.0.8.</span> <span class="toc-text">NSData</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#从文件和URL-加载数据。"><span class="toc-number">1.0.8.1.</span> <span class="toc-text">从文件和URL 加载数据。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#序列化和反序列化"><span class="toc-number">1.0.9.</span> <span class="toc-text">序列化和反序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设计模式"><span class="toc-number">1.0.10.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#模型－视图－控制器模式"><span class="toc-number">1.0.10.1.</span> <span class="toc-text">模型－视图－控制器模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#委托模式"><span class="toc-number">1.0.10.2.</span> <span class="toc-text">委托模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KVO"><span class="toc-number">1.0.10.3.</span> <span class="toc-text">KVO</span></a></li></ol></li></ol></li></ol></nav></div></aside><main class="main" role="main"><div class="content"><article id="post-object-c-learning-3" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">object-c 第三章</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/2018/02/11/object-c-learning-3/" class="article-date"><time datetime="2018-02-11T11:45:25.000Z" itemprop="datePublished">2018-02-11</time></a></span> <span class="article-category"><i class="icon icon-folder"></i> <a class="article-category-link" href="/categories/学习/">学习</a></span> <span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link" href="/tags/object-c/">object-c</a></span> <span class="article-read hidden-xs"><i class="icon icon-eye-fill" aria-hidden="true"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></span> <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2018/02/11/object-c-learning-3/#comments" class="article-comment-link">Comments</a></span></div></div><div class="article-entry markdown-body" itemprop="articleBody"><h1 id="第三章-框架"><a href="#第三章-框架" class="headerlink" title="第三章 框架"></a><center>第三章 框架</center></h1><p>框架是构成支持所有Objective-C 开发的库的基础。其中包括提供了对诸如字符串，数组，字典，其他通用对象及其适配的方法的支持。</p><p>框架比Cocoa库处于更低的抽象层次。Cocoa库和UIKit套件关心的应用程序，视图以及用户输入，而框架则关注组织数据的底层任务。在本章中，你将学习框架提供的一些重点类，以及了解Cocoa 和 Cocoa Touch 所依赖的设计模式。</p><h3 id="可变和不可变对象"><a href="#可变和不可变对象" class="headerlink" title="可变和不可变对象"></a>可变和不可变对象</h3><p>框架里面几乎所有存储数据的对象都分成两种：可变和不可变。可变对象可在对象创建后被修改，不可变对象则不能。</p><p>例如，NSArray类，它把对象存储成一个列表，但你不能往里添加，删除，替换对象。如果你想改变它的内容，则需要使用NSMutableArray类。</p><p>为什么有可变和不可变对象呢？两个理由：</p><ol><li>如果一个对象是不可变的，说明它所在内存是不能被修改的，因此更有效率。</li><li>如果你传递了一个不可变对象给另一个对象，可以明保证这个对象永远不能被其他对象修改。</li></ol><p>你可以为一个已有对象创建其不可变的版本。（反之亦然－你可以创建其可变的版本）例如，通过NSArray 创建 NSutableArray（后续章节会更详细介绍）：</p><pre><code>// here, &apos;someArray&apos; is an NSArray
NSMutableArray* mutableArray = [NSMutableArray arrayWithArray: someArray];
</code></pre><p>可变和不可变对象都有各自的用处。大多数情况，编写Mac 和 iOS 应用时用到的是不可变对象。Cocoa常把这些对象作为参数传递，保证类似传递NSArray对象给另一个方法时，不会修改其内容。如果你是java开发者，可能对这种从语言级别区分可变和不可变对象会感到一丝陌生，因为java里习惯使用可变对象。不过随着使用时间变长，你会发现这种区分很有用。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>简单来说，字符串就是一块文本信息。Objective-C应用处理到文本的地方，基本都会用到NSString，以后你会慢慢熟悉NSString的。</p><p>由于字符串可存储文本，所以常用于存储我们所写的自然语言（一般用unicode编码）。</p><h4 id="字符串的创建"><a href="#字符串的创建" class="headerlink" title="字符串的创建"></a>字符串的创建</h4><p>字符串用NSString 类表示，使Objective-C 对待字符串像其他对象一样。你可以这样创建一个空字符串：</p><pre><code>NSString* aString = [[NSString alloc] init];
</code></pre><p>不推荐这样做，因为NSString 类是不可变的，所以上面创建的空字符串不能被修改。其他的创建方法，比如通过加载文件内容创建，或在代码提供内容来创建，会更有用。</p><p>Objective-C 使用字符串是非常普遍的，故此提供了一种快速创建方法：</p><pre><code>NSString* aString = @&quot;Hello, World!&quot;;
</code></pre><p>注意双引号前面的‘@’ 符号，它告诉编译器创建的是NSString对象而不是C标准的字符串（不属于Objective-C 对象）。因为NSString 是符合Objective-C 标准的对象，所以它可以几首消息，并和应用中其他对象通信。比如，你可以获取新字符串又多少个字符：</p><pre><code>NSInteger sizeofString = [@&quot;Hello, world!&quot; length];
</code></pre><p>用这种语法定义的字符串对象称为文本型字符串。</p><h4 id="字符串的使用"><a href="#字符串的使用" class="headerlink" title="字符串的使用"></a>字符串的使用</h4><p>字符串对象提供良好的扩展性和内置大量的方法。大多数情况，字符串有两种用途：处理自然语言和文件路径。这意味NSString 提供大量的方法用于处理这些数据。</p><p>NSString 创建的三种方法：</p><ol><li>使用文本，如：@“this example”。</li><li>由其它数据加载，如文件</li><li>由已存在的字符串。</li></ol><p>由文本创建字符串的语法：</p><pre><code>NSString* constantString = @&quot;Text of the string&quot;;
</code></pre><p>这种创建的字符串对象，可以直接添加到数组和字典里，后续详细介绍。</p><h5 id="大小写和路径"><a href="#大小写和路径" class="headerlink" title="大小写和路径"></a>大小写和路径</h5><p>由于字符要处理自然语言，所以提供一些使用的方法用做转换处理。<br>如大小写转换：</p><pre><code>NSString* originalString = @&quot;This is An Example&quot;;

// &quot;THIS IS AN EXAMPLE&quot;
NSString* uppercase = [originalString uppercaseString]

// &quot;this is an example&quot;
NSString* lowerCaseString = [originalString lowercaseString];

// &quot;This Is An Example&quot;
NSString* capitalizedString = [originalString capitalizedString];
</code></pre><p>注意，调用上述方法不会改变原字符串，因为它是不可变的；相反，凡涉及处理字符串内容的方法，都会返回一个新字符串对象。</p><h5 id="查找子符"><a href="#查找子符" class="headerlink" title="查找子符"></a>查找子符</h5><p>在使用字符串时，有时需要提取子串，例如从“hello world” 中的hello。</p><p>为了提取子串，可以指定从原字符串的某位置开始直到结尾或从开头到指定位置结束进行查找。也可以在指定的范围内的字符进行查找。</p><p>想得到一个字符串前5个字符，可以：</p><pre><code>NSString* startSubstring = [originalString substringToIndex: 5]; // &quot;This &quot;
</code></pre><p>想得到一个字符串从第5个位置往后的所有字符，可以：</p><pre><code>NSString* endSubstring = [originalString substringFromIndex: 5]; // &quot;is An EXAMPLE&quot;
</code></pre><p>想得到某范围内的字符，首先要创建一个 NSRange 的结构体，它定义了范围值。比如，指定从第3个字符开始长度为5的字串，可以：</p><pre><code>NSRange theRange = NSMakeRange(2, 5);
</code></pre><p>NSRange 有两个变量：位置和长度。位置是从0开始，所以上面的定义需要从2开始。</p><p>一旦定义好了NSRange，就可以这样获取子串：</p><pre><code>NSRange theRange = NSMakeRange(2, 5);
NSString* subString = [originalString substringWithRange: theRange]; //&quot;is is&quot;
</code></pre><h4 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h4><p>字符串比较是常用的操作，不过，不能像下面的代码这样做：</p><pre><code>// firstString contains &quot;one&quot; and secondString is another object,
// also containing &quot;one&quot;
if (firstString == secondString){
  // do something
}
</code></pre><p>因为 == 操作符只是比较两个变量的指针，实际上检查两个变量在内存位置是否一样，通常结果是否定的。</p><p>正确的做法是使用 isEqualToString: 方法：</p><pre><code>if ([firstString isEqualToString: secondString]){
  // do something
}
</code></pre><p>当两个字符串内容完全相同，方法返回True，否则False。这个方法大小写敏感。</p><h4 id="搜索字符串"><a href="#搜索字符串" class="headerlink" title="搜索字符串"></a>搜索字符串</h4><p>除了检查两个字符串是否一样，你还可以获取字符串所包含更多信息。在Cocoa，你可以查找字符串是否包含特定的子串，或者对比两个字符串看看他们如何排序。</p><p>查找子串，还是使用rangeOfString 系列方法。调用这些方法，如果子串找到，会返回NSRange，否则，返回的NSRange 中的位置变量是一个NSNotFound常量。例如：</p><pre><code>NSString* sourceString = @&quot;Four score and seven ago&quot;;
NSRange range = [sourceString rangeOfString: @&quot;seven&quot;];
if(range.location == NSNotFound){
  // the string was not found
} else {
  // the string was found; &apos;range&apos; variable contains info on where it is
}
</code></pre><p>搜索子串还可以限制范围，或提供可选参数。比如：可以在搜索子串时忽略大小写：</p><pre><code>NSString* sourceString = @&quot;Four score and seven years ago&quot;;
NSRange range = [sourceString rangeOfString: &quot;SEVEN&quot; options: NSCaseInsensitiveSearch];
</code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>简而言之，数组是对象的列表。它按序存储对象，允许你一次引用一个或全部对象。</p><p>数组是Cocoa 里重要的容器类之一，因为它可以在内存允许的情况下存储任意多的对象。任何时候一个方法需要使用一个或多个对象，NSArray几乎都可以用于存储它们。</p><p>和NSString一样，NSArray是不可变的－－一旦被创建，就不能新加或移除其中的对象。所以，创建NSArray时，需要提供要存储的对象。有多种方法可以实现，比如：使用其他数组的元素来创建。</p><p>只要是Objective－C 对象，都可以存储在数组，这些对象不需要是相同的类型－－可以将NSString对象和NSView对象存储在同一数组。数组也可以存储其他数组，因为NSArray 本身也是对象。</p><p>类似NSString的对象，创建NSArray对象也是特别的：</p><pre><code>NSArray* myArray = @[@&quot;one&quot;, @&quot;two&quot;, @&quot;three&quot;];
</code></pre><p>这样就创建了一个新的，不可变的，且包含NSString对象的数组。</p><p>要从数组中获取某对象，语法是：</p><pre><code>NSString* oneString = myArray[0];
NSString* twoString = myArray[1];
</code></pre><p>数组需要注意的地方：</p><ul><li>数组从0开始计数，对应第一个对象，其他依此类推。</li><li>如果使用无效的下标，会导致异常或崩溃。比如，一个有3个对象的数组，你想取下标为3的对象，就会导致异常（下标3对应第4个对象）。</li><li><p>iOS5 以下的版本不支持直接访问数组元素的，你需要使用较为啰嗦的方法objectAtIndex: ，如下：</p><pre><code>NSString* oneString = [myArray objectAtIndex: 0];
</code></pre><p>这个方法兼容iOS 7， 所以如果你的代码要兼容其他版本，就可以用这个方法。</p></li></ul><p>同样地，你也可以通过count 属性获取数组元素的个数。</p><pre><code>int count = myArray.count;
// count now equals 3
</code></pre><p>由于NSArray 是对象，所以和其他对象一样可以接收消息。比如，要获知某对象在数组的下标可发送indexOfObject: 方法，如果不存在，方法就返回一个特殊值 NSNotFound：</p><pre><code>NSArray* myArray = @[@&quot;one&quot;, @&quot;two&quot;, @&quot;three&quot;];
int index = [myArray indexOfObject: @&quot;two&quot;]; // should be equal to 1

if (index == NSNotFound){
    NSLog(@&quot;Couldn&apos;t find the object!&quot;);
}
</code></pre><p>若要从其他数组创建一个新数组，可以使用subArrayWithRange: 方法，它需要一个NSRange 参数。新数组里面的对象不会复制过来–即两个数组共同引用这些对象，所以其中一个数组修改了某个对象的属性，必然影响另一个。</p><pre><code>如果你想把对象拷贝过来，你可以发送copy 消息，它会返回对象一个副本。但不是所有对象都支持拷贝，需要对象实现NSCopying 协议。
</code></pre><p>下面是一个例子：</p><pre><code>NSArray* myArray = @[@&quot;one&quot;, @&quot;two&quot;, @&quot;three&quot;];
NSRange subArrayRange = NSMakeRange(1,2);
NSArray* subArray = [myArray subArrayWithRange: subArrayRange];
// subArray now contains &quot;two&quot;, &quot;three&quot;
</code></pre><h3 id="快速列举"><a href="#快速列举" class="headerlink" title="快速列举"></a>快速列举</h3><p>对于一个容器，有时需要访问它里面的每一个对象，Objective-C 有个特性叫快速列举，允许你快速高效遍历容器的对象。</p><p>遍历数组对象，你需要这样做：</p><pre><code>NSArray* myArray = @[@&quot;one&quot;, @&quot;two&quot;, @&quot;three&quot;];

for(NSString* string in myArray){
  // this code repeated 3 times, one for each item in the array
}
</code></pre><p>编译器会自动产生低开销的代码遍历容器每一个项。</p><h3 id="可变数组"><a href="#可变数组" class="headerlink" title="可变数组"></a>可变数组</h3><p>之前讨论的都是不可变数组NSArray，不过有时想要对数组的元素进行增删改，要怎么做呢？使用NSMutableArray 类即可。</p><p>NSMutableArray 是NSArray 的子类，所以NSArray能做的，NSMutableArray 也能做到，同样，以NSArray 为参数的方法，可以把NSMutableArray 作为实参传递过去（类的向上转型）</p><p>通过addObject: 和 insertObject: atIndex: 方法，可以往NSMutableArray 添加对象。前者将新的对象添加到数组的结尾，而后者则把对象插入指定的位置：</p><pre><code>NSMutableArray* myArray = [NSMutalbeArray arrayWithArray: @[@&quot;One&quot;, &quot;Two&quot;]]

// Add &quot;Three&quot; to the end
[myArray addObject: @&quot;Three&quot;];

// Add &quot;Zero&quot; to the start
[myArray InsertObject: @&quot;Zero&quot; atIndex: 0];
</code></pre><p>删除对象，则对应用removeObject: 和removeObjectAtIndex: 方法：</p><pre><code>NSMutableArray* myArray = [NSMutableArray arrayWithArray: @[@&quot;One&quot;, @&quot;Two&quot;, @&quot;Three&quot;]];

[myArray removeObject: @&quot;One&quot;]; // remove &quot;One&quot;
[myArray removeObjectAtIndex: 1]; // remove &quot;Three&quot;, the second item in the array at this point
// The array now contains just &quot;Two&quot;

注意，removeObject: 方法会把相同的对象实例全部删除，比如，如果字符串对象@“One” 在数组中出现两次，调用方法时，两个都会被删除。
</code></pre><p>替换数组中的对象，可以使用replaceObjectAtIndex: withObject: 方法，这个方法需要传递位置和要替换的对象：</p><pre><code>NSMutableArray* myArray = [NSMutableArray arrayWithArray: @[@&quot;One&quot;, @&quot;Two&quot;, @&quot;Three&quot;]];
[myArray replaceObjectAtIndex: 1 withObject: @&quot;Bananas&quot;];
// myArray is now &quot;One&quot;, &quot;Bananas&quot;, &quot;Three&quot;
</code></pre><p>也可以直接给可变数组赋值来替换对象：</p><pre><code>myArray[0] = @&quot;Null&quot;;

提示：只有可变数组才能这么做，不可变数组则不可以。你也不能用这种方法新增和删除对象，只能用于替换数组中一个已经存在的对象。
</code></pre><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>数组只是简单地存储对象的列表，字典较之更为复杂。字典可通过键值（凡支持拷贝的对象都可以作为键值，通常用NSString）映射来存储对象。</p><p>你可以将字典看作一个表。比如你想存储联系人的信息，就可以用字典表示：</p><pre><code>key            value
----------------------
Name        Cave Johnson
Company    Aperture Science
Likes        Science
Dislikes    Lemons
</code></pre><p>当你想找到联系人的公司信息，通过Company 这个键值找到对应的值 Aperture Science。</p><p>NSDictionary 和表的工作原理是一样的，而存储对象则和NSArray类似，不同的是多了个键值。</p><p>当创建NSDictionary 对象时，需要提供键值和要存储的对象，否则不能创建。</p><p>创建语法如下：</p><pre><code>NSDictionary* translationDictionary = @{
    @“greeting”: @&quot;Hello&quot;,
    @&quot;farewell&quot;: @&quot;Goodbye&quot;
};
</code></pre><p>取字典存储对象：</p><pre><code>NSDictionary* translationDictionary = @{@&quot;greeting&quot;: @&quot;Hello&quot;};
NSString* greeting = translationDictionary[@“greeting”];
</code></pre><p>如果对象没找到，则返回nil。</p><p>字典也可以用快速列举，只需要遍历字典每一个键值。要得到对应对象值，可以用objectForKey: 方法:</p><pre><code>// Here, aDictionary is an NSDictionary

for(NSString* key in aDictionary){
  NSObject* theValue = aDictionary[key];
  // do something with theValue
}
</code></pre><p>和NSArrays 一样，NSDictionary 也是不可变的，如果要创建可变字典，使用NSMutableDictionary 类，它是NSDictionary 子类，允许新增和删除字典存储的对象。</p><p>设置字典的值，可以使用和设置数组值的相同方法。插入对象时，需要要键值对应。如果对象已经存在，则会被替换。</p><pre><code>NSMutableDictionary* aDictionary = @{};
aDictionary[@&quot;greeting&quot;] = @&quot;Hello&quot;;
aDictionary[@&quot;farewell&quot;] = @&quot;Goodbye&quot;;
</code></pre><h3 id="NSValue-和NSNumber"><a href="#NSValue-和NSNumber" class="headerlink" title="NSValue 和NSNumber"></a>NSValue 和NSNumber</h3><p>诸如NSArray 和 NSDictionary等容器类只能存储Objective-C 对象。不过Objective－C里并不是所有的东西都是对象，比如整型和布尔型的值，再如之前讨论的NSRange，都不是对象，因此也就不能存储在数组和字典中。</p><p>为了解决这个问题，Cocoa 使用一些类来将非对象的值转换称对象进行存储，而这些对象，可以被存储在容器里。</p><p>NSValue 用于存储多种非对象类型值。NSNumber 只处理和数字相关的，它继承自NSValue。</p><p>由数字创建NSNumber 对象，只需在数字前使用‘@’，编译器自动推断数字的类型（double， float, character, boolean等）：</p><pre><code>NSNumber* theNumber = @123;
</code></pre><p>若要获得存储的数值，可以：</p><pre><code>int myValue = [theNumber intValue];
</code></pre><p>NSNumber 实例对象，可以添加到任何容器类的对象：</p><pre><code>// &apos;numbers&apos; is an NSMutableArray
[numbers addObject: theNumber];
</code></pre><p>NSNumber 还可以通过表达式赋值：</p><pre><code>int a = 100;
NSNumber* number = @(a + 1);
// &apos;number&apos; contains 101
</code></pre><h3 id="NSData"><a href="#NSData" class="headerlink" title="NSData"></a>NSData</h3><p>当你开发程序时，通常要处理一系列数据。大多数情况，这些数据是从磁盘加载并需要用于对象，或者准备把数据写到磁盘。比如，你加载了一张图片到内存，在内存的角度，图片只是一些字节，在使用这图片前，你必须把这些数据转换称UIIMage对象。</p><p>NSData被设计成数据的容器。它由字节构成，并且对字节的类型不做任何假设。无论你操作的是文件或者操作从网络加载的信息，接收后的信息都转换成NSData对象，然后再转换成其他对象。</p><p>NSData 是不可变对象，同样的，也有可变的，即NSMutableDAta。NSMutableData 在不能一次性加载所有字节的情况下比较有用，比如下载文件。</p><h4 id="从文件和URL-加载数据。"><a href="#从文件和URL-加载数据。" class="headerlink" title="从文件和URL 加载数据。"></a>从文件和URL 加载数据。</h4><p>大多数情况都会通过磁盘加载文件或URL来创建NSData对象，或者把其他对象转换成NSData对象，这样就能把数据写到磁盘，更多的细节后续会讲到。</p><p>从磁盘加载文件，你首先要有文件路径。你也可以通过URL来加载文件。</p><p>例如加载一个文本文件到NSData对象，可以这样：</p><pre><code>// Assuming that there is a text file at /Examples/Test.txt:
NSString* fielPath = @&quot;/Examples/Test.txt&quot;;
NSData* loadedData = [NSData dataWithContentsOfFile: filePath];
</code></pre><p>因为NSData 对象只能存储数据，接收字节以及写数据到磁盘而不能做其他事情，所以有很多类都设计了处理NSData对象的方法。</p><p>比如，把NSData对象转换成NSString，可以使用NSString的initWithData: encoding: 方法，参数分别为NSData 和 NSStringEncoding（指定了字节的解码方式）：</p><pre><code>NSString* loadedString = [[NSString alloc] initWithData: loadedData encoding: NSUTF8StringEncoding];

提示：上述方法加载字符串不是最高效的方式，只是为了说明NSData 的用法，更好的方法是stringWithContentsOfFile: encoding: error: , 一步到位。
</code></pre><p>你可以把NSData 对象写入磁盘，使用的方法是 writeToFile: atomically: 。方法需要提供写入路径和一个是否是原子操作的布尔值。如果这个布尔值为YES，NSData先把字节写到临时文件，然后把文件移到指定路径。如果是NO，直接写入目标文件。原子操作会使写入非常慢，因为文件系统需要做移动文件等额外工作，不过这样可以避免程序退出或中途崩溃带来的问题。</p><h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h3><p>当你用到自己所设计的类的对象时，若能把这些对象存储在磁盘并且在需要时再加载到内存是非常有用的。这就是所谓的序列化和反序列化。通过序列化，你可以将任何对象转换成NSData对象。一旦转换成NSData，你就可以像之前所说的进行读写磁盘。将一个NSData对象还原则称为反序列化。</p><p>要使用序列化，类必须实现NSCoding协议。序列化就是为相关对象编码成可写入的字节。反序列化则为读入的字节进行解码并重建对象。</p><p>NSCoding协议有两个主要的方法构成：</p><ul><li>encodeWithCoder:</li><li>initWithCoder:</li></ul><p>任何时候需要为类序列化时，可调用encodeWithCoder: 方法，它要传递NSKeyedArchiver 对象作为参数，用于为对象编码。</p><p>当从磁盘加载对象时，可调用initWithCoder: 方法，对象就可以根据encodeCoder: 方法序列化后的对象重建自己。这个方法要传递NSKeyedUnarchiver 对象作为参数，用于恢复所存数据。</p><p>当加载一个对象时，需调用initWithCoder: 方法而不是init方法意味着initWithCoder必须也要实现init方法所实现的逻辑。</p><p>NSKeyedArchiver 对象的工作原理跟一个可变字典比较类似－使用encodeObject: forKey: 方法并需要传递键值和对象两个参数(相关方法还有 encodeInteger: forKey: 和encodeFloat: forKey:)。方法返回的对象可被序列化以及能够存储到磁盘。</p><p>下面是实现encodeWithCoder: 方法的例子：</p><pre><code>-(void) encodeWithCoder: (NSKeyedArchiver*) aCoder{
  // Store a string (or any other Objective-C object that supports coding)
  [aCoder encodeObject: myuStringVariable forKey: @&quot;myString&quot;];

  // Store a number
  [aCoder encodeInteger: myIntegerVariable forKey: @&quot;anInteger&quot;];
}
</code></pre><p>对应initWithCoder: 方法的实现：</p><pre><code>- (id) iniWithCoder: (NSkeyedUnarchiver*) aDecoder {
  self = [super init];

  myStringVariable = [aDecoder decodeObjectForKey: @&quot;myString&quot;];
  myIntegerVariable = [aDecoder decodeObjectForKey: @&quot;anInteger&quot;];

  return self;
}

提示： 如果试图反序列化一个不存在的对象，解码器会抛出异常并且导致程序会崩溃。
</code></pre><p>大部分Cocoa对象都支持序列化和反序列化－比如支持序列化的有 NSArray, NSData和NSDictionary。其他对象是否支持序列化，可以查看类的文档确认是否实现了NSCoding协议。</p><p>把一个对象转换成可用NSData, 可以这样做：</p><pre><code>// myObject is an object that
// conforms to NSCoding
NSData* object storedData = [NSKeyedArchiver archivedDataWithRootObject: myObject];

// storedData can now be written to a file
</code></pre><p>反过来，则需：</p><pre><code>// loadedData is NSData loaded from somewhere, and SomeObject is
// a class that conforms to NSCoding
SomeObject* myObject = [NSKeyedUnarchiver unarchiveObjectWithData: loadedData];
</code></pre><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>Cocoa 是由一系列设计模式构建而成的。下面将介绍三个主要的设计模式，分别为：模型－视图－控制器模式(MVC)，delegation模式(委托模式)以及键－值观察者模式（key-value observing)。</p><h4 id="模型－视图－控制器模式"><a href="#模型－视图－控制器模式" class="headerlink" title="模型－视图－控制器模式"></a>模型－视图－控制器模式</h4><p>这个模式是Cocoa最重要的模式，它将对象按职责分成三类：模型，视图，控制器。</p><ul><li>模型是包含数据的对象或者协调存储、管理和分发数据的对象。简单的模型对象可以是NSString，而更复杂的可以是整个数据库－它们的目的都是存储数据或者向其他对象提供数据。模型关心的是管理如何存储数据，而对其他对象如何处理这些数据则毫不关心。</li><li>视图负责直接和用户交互，它给用户提供信息和接收用户输入。视图只负责展示数据而不管理数据并在和用户交互时负责通知其他对象。</li><li>控制器是模型和视图之间的媒介，并且包含了应用的大量业务逻辑－即定义程序是什么和如何响应用户输入的逻辑。控制器至少需要负责从模型接收数据，并将数据提供给数据。它也会在用户和视图交互时负责向模型提供信息。</li></ul><p>为了更好说明这个模式，就拿编辑器程序举个例子，比如，编辑器程序从磁盘加载文本文件并把文本内容展示给用户，用户修改了文本内容并且保存修改到磁盘。</p><p>我们可以将这个程序分成模型，视图和控制器对象：</p><ul><li>模型对象负责从磁盘加载数据和将数据写回磁盘以及负责把文本以NSString方式提供给任何需要的对象。</li><li>视图对象则负责要求某对象提供NSString类型数据并且展示给用户以及负责接收来自用户的输入。无论何时，只要用户有输入，编辑器会通知某对象文本的变更，同样，用户需要保存更改时，编辑器也能通知到某对象。</li><li>控制器对象则负责委托模型对象从磁盘加载文件，并将文本传递给视图对象。当文本有更改时，控制器就接收到更新消息。最后，用户要求保存更改会通过视图通知到控制器，这时，控制器会再次委托模型去实际执行把文件写回到磁盘的工作。</li></ul><p>通过这样区分职责，修改起程序来就变得更容易了。</p><p>比如，开发者决定下一个版本的程序支持保存文件到互联网，此时只需修改模型，控制器和视图只需保持不变。</p><p>通过清晰定义对象的职责，在维护时修改起来就比较容易。比如，如果开发者决定添加拼写检查功能，应该修改控制器的代码，因为控制器跟如何展示文本和如何存储文本没有关系。</p><p>本章讲到的一些主要类如NSData，NSArray和NSDictionary，都可以作为模型。因为它们负责存储数据和向其他类展示信息。NSKeyedArchiver则可作控制器，因为它接收信息并且有处理信息的逻辑。NSButton 和UiTextField 则可作为视图的例子，因为它们仅仅是给用户展示信息。</p><h4 id="委托模式"><a href="#委托模式" class="headerlink" title="委托模式"></a>委托模式</h4><p>委托模式是指对象将某些职责委托给别的对象去完成。例如，UIApplication对象，它表示iOS的应用实例。当应用转到后台运行时，需要清楚什么是应该发生的。好多语言处理这用问题时用到的子类化－比如C++，会为UIApplication类定义一个空方法applicationDidEnterBackground,然后开发者需创建UIApplication 的子类，在覆盖applicationDidEnterBackground方法。</p><p>不过，这种方法特别勉强并且会导致额外的问题－增加了代码的复杂行，也说明如果你想覆盖两个类的方法时，你需要创建两个独立的子类。Objective-C则是基于运行时确定对象，无论另一个对象是否能够响应消息来解决这个问题。</p><p>一个对象想要另一个对象知道将要发生什么或已经发生了什么，可存储一个对象引用。这个被引用的对象则是委托对象。当事件发生时，它会检查委托的对象是否实现了匹配事件的方法－对于UIApplication类的委托对象，例如，检查委托对象是否实现了applicationEnterBackground方法。如果实现了，该方法则被调用。一个对象可同时作为多个对象的委托。</p><p>正是因为这种松耦合，一个对象作为多个对象的委托的可能的。比如，某个对象可以是一个声音回放对象和一个图片对象的委托，当声音回放完成和相机捕获完图像后，都能接收到通知。</p><p>委托里用到的具体方法通常在协议中列出。比如，如果你的对象想要作为AVAudioPlayer对象的委托，则它需要实现AVAudioPlayerDelegate 协议。</p><h4 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h4><p>大多数MVC的实现都依赖控制器及时提供有模型到视图的更新，反之亦然。另一种方式是周期性检查模型和询问模型是否有变更，如果有，然后就向视图提供信息。不过，如果模型不是经常变更，OS X和iOS应用多数情况下模型就不怎么变更，这种方法就很低效了。为了迅速响应，故此Cocoa 实现了所谓的KVO模式。</p><p>在这个模式中，对象可能注册到其他对象成为观察者。当被观察者发生变更时，就会通知到那些观察者。</p><p>在分离视图和模块对象中，KVO起到重要作用。更多细节，后续章节会讨论。</p></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="https://sucaizi.github.io/2018/02/11/object-c-learning-3/" title="object-c 第三章" target="_blank" rel="external">https://sucaizi.github.io/2018/02/11/object-c-learning-3/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><div class="panel panel-default panel-badger"><div class="panel-body"><figure class="media"><div class="media-left"><a href="https://github.com/sucaizi" target="_blank" class="img-burn thumb-sm visible-lg"><img src="https://avatars1.githubusercontent.com/u/1609965?s=460&amp;v=4" class="img-rounded w-full" alt=""></a></div><div class="media-body"><h3 class="media-heading"><a href="https://github.com/sucaizi" target="_blank"><span class="text-dark">future</span><small class="ml-1x">Web Developer &amp; Java Developer</small></a></h3><div>某公司核心开发者，从事编程事业5年有余。</div></div></figure></div></div></div></article><section id="comments"><div id="uyan_frame"></div></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="prev"><a href="/2018/02/11/object-c-learning-4/" title="object-c 第四章"><i class="icon icon-angle-left" aria-hidden="true"></i>&nbsp;&nbsp;Newer</a></li><li class="next"><a href="/2018/02/11/object-c-learning-2/" title="object-c 第二章">Older&nbsp;&nbsp;<i class="icon icon-angle-right" aria-hidden="true"></i></a></li></ul><button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning hidden-xs" data-toggle="modal" data-target="#donateModal"><span>$</span></button><div class="bar-right"><div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div><div class="toggle-toc hidden-xs"><a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="Catalogue" role="button"><i class="text-collapsed icon icon-anchor"></i> <i class="text-in icon icon-close"></i></a></div></div></div></nav><div class="modal modal-center modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog"><div class="modal-dialog" role="document"><div class="modal-content"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><div class="modal-body"><div class="donate-box"><div class="donate-tit"><p>Thank you for your support, I will continue to work hard!</p></div><div class="donate-payimg"><img src="/images/donate/zfb-1.png" alt="Scan Qrcode" title="Scan"></div><p class="text-muted mv">Scan this qrcode</p><div class="donate-payselect"><div class="pay_item checked" data-id="alipay" data-src="/images/donate/zfb-1.png"><div class="radio"><input type="radio" name="payment" id="input-alipay" value="alipay" checked><label class="pay_logo clickable" for="input-alipay"><img src="/images/donate/alipay.jpg" alt="alipay"></label></div></div><div class="pay_item" data-id="weipay" data-src="/images/donate/wx-1.png"><div class="radio"><input type="radio" name="payment" id="input-weipay" value="weipay"><label class="pay_logo clickable" for="input-weipay"><img src="/images/donate/weipay.jpg" alt="weipay"></label></div></div></div><div class="text-grey"><p>Scan this qrcode, you can sweep yards reward oh!</p></div></div></div></div></div></div></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/sucaizi" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li></ul><div class="copyright"><div class="publishby">Theme by <a href="https://github.com/cofess" target="_blank">cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.</div></div></footer><script src="https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>!function(T){var n={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)"},ROOT_URL:"/",CONTENT_URL:"/content.json"};T.INSIGHT_CONFIG=n}(window)</script><script src="/js/insight.js"></script><script defer src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><script defer type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=[object Object]"></script><script defer>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?2f7e3cfec9131e639ed8f077b6e43d83";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></body></html><!-- rebuild by neat -->
{"meta":{"title":"future's blog","subtitle":null,"description":"Web & Java Developer","author":"future","url":"https://sucaizi.github.io"},"pages":[{"title":"","date":"2018-02-07T14:59:48.456Z","updated":"2018-01-07T14:08:48.478Z","comments":true,"path":"404.html","permalink":"https://sucaizi.github.io/404.html","excerpt":"","text":""},{"title":"书单","date":"2018-02-07T15:02:00.598Z","updated":"2018-02-04T14:54:31.000Z","comments":false,"path":"books/index.html","permalink":"https://sucaizi.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-02-07T15:01:37.380Z","updated":"2018-02-04T14:54:31.000Z","comments":true,"path":"links/index.html","permalink":"https://sucaizi.github.io/links/index.html","excerpt":"","text":""},{"title":"关于","date":"2015-11-29T15:29:07.000Z","updated":"2018-02-11T10:04:15.876Z","comments":false,"path":"about/index.html","permalink":"https://sucaizi.github.io/about/index.html","excerpt":"","text":"hi，我是future，是一名程序员我的经历2007 - 2011 - 计算机本科毕业2011 - 今 - pc web前端开发, java 后端开发我懂些啥…数据库：mysql，oracle语言：delphi，java, js/html/javascript, python,我正在折腾…web: nodejs 妄图成为全栈开发app: object-c 玩点小应用database：mongodb，mysqllanguage: js,html,css,ruby其实我还喜欢…弹吉他，入门级菜鸟，不提了，但仍在坚持学看看小文章，装文艺必备篮球，打得不错xbox游戏编程，码字打算…和女朋友养只肥猫"},{"title":"分类","date":"2018-02-11T09:57:06.396Z","updated":"2018-02-11T09:57:06.395Z","comments":false,"path":"categories/index.html","permalink":"https://sucaizi.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-02-10T09:22:24.213Z","updated":"2018-02-10T09:22:24.213Z","comments":false,"path":"repository/index.html","permalink":"https://sucaizi.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2015-12-03T14:56:35.000Z","updated":"2018-02-11T10:00:02.720Z","comments":false,"path":"tags/index.html","permalink":"https://sucaizi.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"object-c 第五章","slug":"object-c-learning-5","date":"2018-02-11T11:45:32.000Z","updated":"2018-02-11T11:52:20.563Z","comments":true,"path":"2018/02/11/object-c-learning-5/","link":"","permalink":"https://sucaizi.github.io/2018/02/11/object-c-learning-5/","excerpt":"","text":"第五章 图形用户界面（GUI）图形用户界面是现代计算机的特征之一。几乎所有的消费型个人电脑都离不开图形界面，只有那些使用服务器，超级计算机或其他特殊用途的电脑才不需要。为用户设计图形界面是开发Cocoa的基础，理解如何设计有吸引力和稳定的图形界面以及如何实现，更是开发者的重要技能。本章讨论的用户接口使用与Cocoa和Cocoa Touch。设计稳定和有趣的UI 是很大的话题，并不适合本章讨论，所以，如果你对如何设计伟大的用户接口感兴趣，可以参考《Tapworthy by Josh Clark》一书。本章你会学习到OSX 和iOS 核心动画技术。OSX 和 iOS 接口iOS 和OSX 都是通过场景来表示它们的用户接口，而它们接收用户输入的不同方式决定了它们接口的较大区别。在OSX， 顶层对象是window。一个窗体包含控件，比如按钮，标签和文本字段，你可以在场景内移动控件以适合展示给用户。同一时间会在场景内展示多个窗体。有时候窗体需要重画，因为窗体需要在它变大或变小时如何展示其排版。最后，有些窗体可以全屏。这个特点自引入OSX10.7以后就变得越来越普遍。iOS 则通过一种不同的方法来处理窗体。在iOS中，用户一次只能处理一个全屏的场景。每个场景都是由view controller 管理。视图控制器从属应用的窗体，而每次展示在屏幕上只有窗体。几乎所有的iOS应有有且仅有一个窗体，除了多屏展示以外。之前在‘OS X 应用’ 一章中提及应用是通过加载nib文件来加载用户接口的。至于nil这个缩写其实来源于‘NeXT Interface Builder’，从XCode4 开始nib文件就独立发布。MVC和应用设计在第四章曾经讨论过Cocoa大量使用MVC模式来设计。总的来说，MVC设计模式将应用的职责分成三类：模型，处理数据存储；视图，表示用户接口，接受输入输出；控制器，起桥梁作用。Xcode 的Interface Builder仅仅处理视图，剩下的就处理模型和控制器，这样一来，就可以在相对分离的情况下集中精力处理接口。Nib文件广泛地说，Nib是用来存储对象的文件。大多数情况，nib文件只包含接口，不过也可能作为对象的普通容器。Nib文件将所谓的“冻结”对象以序列化的形式存储在文件里，当然包括对象所有的属性（比如，按钮，它的位置，标签文本以及其他信息）。当应用需要展示一个窗体时，就需要加载nib文件，“解冻”这些对象，并展示给用户。基于此，nib文件也可以存储自定义类的对象。因此，在nib文件加载时，你也可能创建你自己的类的实例，然后，将它和视图连接起来。除非你所设计的界面不对用户进行任何响应，否则，你需要将视图和你的控制器连接起来－即你自定义的代码。有两种方法实现这样的连接：outlets和actions。后面将会讨论。Nib文件结构Nib文件包含了一棵对象树。这个树有多个根节点－比如，一个nib文件可能包含两个窗体，每个窗体都有各自的按钮和其他控件。位于顶层位置的对象称为“顶层对象”。“顶层对象”通常就是展示给用户的东西－OSX 对应是窗体，iOS 对应是视图控制器。不过nib文件里任何对象都可以作为“顶层对象”。在OSX，任何在屏幕显示的东西，都放在窗体。在Inface Builder 定义了很多不同类型的窗体：标准窗体 屏幕上通用的窗体。可以全屏，通常是应用的主窗体。 控制面板窗体 通常应用程序处于非活动状态时隐藏起来。 比如 inspector窗口和其他从属的窗口通常使用的面板。 带纹理窗体 和标准窗体不同，它又各种不同的背景颜色。这种窗体经常发生改变，曾经是细条纹，拉丝金属的，现在则更为简洁（如OS X10.7）。 HUD 这类窗体都深灰色，半透明，主要设计来显示当前所选或包含的辅助操作。多用于多媒体应用，比如QuickTime。 窗体可以包含任意视图。关于视图的更多信息，后续第七章会讨论。不过在iOS，任何时候，仅能显示一个窗口。OSX 则可以放置任意多窗口，并可随用户随意切换。为了管理好不同类型的屏幕内容，iOS使用了一类叫view controller的对象。它可以管理单个视图，也可以管理那些子视图。后面将详细介绍。类似与OSX的窗口，iOS里的view controller 也有多种不同的类型。不同类型定义了不同的结构和行为。标准view controller 仅表示一个视图，通常作为子类加入到屏幕的逻辑上去－实际上，子类化是它的主要作用。 Navigation controller","categories":[{"name":"学习","slug":"学习","permalink":"https://sucaizi.github.io/categories/学习/"}],"tags":[{"name":"object-c","slug":"object-c","permalink":"https://sucaizi.github.io/tags/object-c/"}]},{"title":"object-c 第四章","slug":"object-c-learning-4","date":"2018-02-11T11:45:29.000Z","updated":"2018-02-11T11:52:20.576Z","comments":true,"path":"2018/02/11/object-c-learning-4/","link":"","permalink":"https://sucaizi.github.io/2018/02/11/object-c-learning-4/","excerpt":"","text":"第四章 OS X 和 iOS 应用对用户而言，应用不过是跟系统里的文件一样的东西。毕竟，电脑是为用户设计，而安装的程序又定义了电脑能够做什么。作为一个开发者，很容易陷入构建app的细节－类，方法和结构。不过用户只关心你应用的卖点。在本章，你将了解到OS X 和iOS 应用如何构造，应用能够做些什么，不能做些什么。什么是应用iOS 和OS X 应用的打包方式和其他平台的很不同，尤其Windows平台。在其他平台，工程编译后是一个包含编译代码的二进制文件，之后由开发者将二进制文件和资源文件打包。在Linux，你需要打包文件，在Window，通常要创建一个安装程序。OS X 和iOS 则采用另一种方法。即使用所谓‘包’的概念－对用户而言是一个单独文件。很多文档格式化是用包作为存储和组织数据的有效途径，因为将数据块不做不同的文件存储意味程序无需实现解压单独文件的逻辑。所以应用实际是包含编译好的二进制文件和它需要的资源文件。OS X 和iOS 应用的结构稍有不同，不过如何打包程序的原理是一样的。你可以在Finder中右击应用去展示其内部包含的内容。当你用XCode 编译和创建应用时，XCode 会创建一个包，并复制任何需要的资源到里面。如果你创建的是一个MAC 应用，你可以压缩它并发送到任何人去运行它。在iOS上就有点不同，因为应用必须有代码签名并且放到应用商店后才能在设备运行。这样做的好处之一，就是应用可以在Mac任意变更目录。应用，框架，工具和其他XCode 不但可以创建应用，还可以创建框架。框架和应用的结构差不多，同样有二进制文件和资源文件，但不是独立的且设计给其他应用使用。Mac上一个典型的例子就是 AppKit 框架，在iOS上等同的是UIKit 框架。应用由什么组成？组建以一个iOS 或 OS X应用至少包括两样：已编译的二进制文件描述app 系统信息的文件已编译的二进制文件是由XCode编译并链接。而描述信息会保存在Info.plist文件，其包含：应用图标名应用可以打开何种类型文件已编译的二进制文件名应用启动时加载的接口文件名语言支持应用是否支持多任务（用于iOS）应用归属Mac 应用商店何种分类（用于OS X）这个文件非常重要，如果你移除了它，应用就无法启动。应用同时也包含应编译进来的资源文件－－图片，文件，音频和其他通过XCode工程添加进来的项目。应用可以在运行时引用这些资源。你可以通过一下步骤了解OS X应用的结构：打开XCode，创建一个新的OS X 应用，一切默认后，保存。编译。在导航栏，你可以看到编译后产生的.app 文件，右击文件，选择在Finder 中打开，就会展示app包含什么了。右击应用，选择 ‘显示包内容’，Finder 就会显示其内容。在iOS上，所有东西都包含在包文件的根目录，而OS X更为严格点。比如一个名为MyApp 的Mac应用的结构如下：MyApp.app 包的最上层Contents 一个包含应用的文件夹 Info.plist 应用的系统信息描述 MacOS 一个包含已经编译的二进制文件的文件夹 PkgInfo 描述应用作者和这是个什么应用的文件。 Resources 一个包含已编译的资源文件的文件夹 而在iOS 的结构则如下：MyApp 已编译的二进制文件 Info.plist 描述应用的系统信息的文件 Default.png 应用启动时默认展示的图片 Default@2x.png Default.png 的高分辨率版本 embedded。mobileprovision 描述标识应用可在设备上运行的文件 Entitlements.plist 描述应用可以做什么和不可以做什么的文件 因为你的应用可能安装在系统的任何地方，所以你的代码不可以用绝对路径寻找资源文件，幸运的是，Cocoa 已经考虑到这一点并指导你如何做。使用NSBundle 查找应用的资源随着编码的进行，你的应用需要考虑在不同平台上运行，这时就用到NSBundle 这个类。通过NSBundle 可以获得应用所在的磁盘位置，以及获取已编译的资源。对于iOS应用，这显得尤其重要，因为应用可能安装到任意的位置，你的代码不能依赖某以路径，更不能写死路径。一旦这么做了，在iOS保证会出问题。你可以使用NSBundle 检测应用所在的位置，不过一般只需要知道某单独资源所在的位置，你所要做的，就是给出资源的名字和类型。比如，下面的代码就是返回SomeImage.png 的相对路径：NSString* resourcePath = [[NSBundle mainBundle] pathForResource: @&quot;SomeImage&quot; ofType: @&quot;png&quot;]; // resourcePath is now a string containing the // absolute path reference to SomeImage.png 注意 [NSBundle mainBundle] 这个调用－可能由多个bundle(记住，应用所有的资源都可以作为bundle)你还可以得到资源的URL：NSURL* resourceURL = [[NSBundle mainBundle] URLForResource: @&quot;SomeImage&quot; ofType: @&quot;png&quot;]; 方法会在资源文件夹查找文件（在iOS，则从应用的根目录开始查找）对磁盘的文件而言，使用绝对路径和URL 是一样的，但推荐使用URL。文件的URL 一般是这样的：file:///Applications/Xcode.app/。如果你向工程添加了图像或其他资源，这会把资源都复制到工程编译所在的路径。对与Mac应用而言，资源文件会复制到Resources文件夹，而iOS，则是应用的根目录。应用的生命周期每个程序都有启动，运行和终止的状态。比较有意思的是这些状态切换时做了什么。大多数情况，OS X和iOS 的行为是一样的，除了iOS处理多任务时和标准桌面应用不一样外。在本节，我们将分别讨论这两种应用的生命周期，以及生命周期的状态切换时所发生的事情。####OS X 应用当程序启动时，系统首要做的是打开Info.plist。系统根据这个文件查找到已编译的二进制文件的位置并加载。此时，你编写的代码接管系统。除了编译的代码以外，还有为运行时准备和捆绑的对象集合。这些对象也叫接口对象–准备好窗口，控件和场景－程序编译时存储在nib文件。当应用运行时，这些nib文件就会打开，预先创建的对象就会加载到内存。应用首先打开nib文件并反序列化其内容。即应用加载窗口，控件和取出存储在nib里面的任何东西并链接它们。主nib文件包含了应用的委托对象。从nib文件加载完对象后，就发送awakeFromNib 消息。此时，对象就可以开始运行代码了。总而言之，从nib文件加载的对象接收的时awakeFromNib消息。而自己代码创建的对象则接收init 方法。此时，应用准备开始运行。接着要做的是向应用委托对象发送applicationDidFinishLaunching:方法，完了，应用就正式进入 run loop 状态。所谓的run loop 是个无限循环，由Cocoa管理，直到程序退出为止。run loop 的目的是监听事件－键盘输入、鼠标移动和点击，计时器暂停等-同时发送这些事件到相关的目标。比如，你有一个事件挂在一个按钮上，当点击按钮时就触发事件。若用户点击了按钮，鼠标点击的事件就发送到按钮，然后就会执行目标事件的代码。在OS X，应用会继续运行即使用户正在运行其他应用。用户在切换其他应用时，应用的委托对象就会收到applicationWillResignActive: 消息，表明应用准备进入非活动状态，接着，会再接收到applicationDidResignActive: 消息。以上两个方法之所以要分离开来，是为了让你的代码在iOS系统按下home键，或在OS X切换应用时更好地管理屏幕上所发生的事。当调用applicationWillResignActive:，应用仍然显示在屏幕，当应用不再可见时，应用就会接收到applicationDidResignActive:消息。如果用户再次切换到原应用，应用就会接收到一对相对应的方法：applicationWillBecomeActive： 和 applicationDidBecomeActive:。这些方法会在应用再次被激活之前和之后立即发送。应用退出时，事件循环就终止。这时，应用会接收到applicationWillTerminate: 消息，这也是应用保存文件最后的时机。iOS 应用iOS 应用的大部分行为和OS X 应用是相同的，仅小部分不同。iOS 设备有限的内存决定了其实现多任务时需要严格使用内存。iOS 同一时间只能有一个应用在屏幕上－其他应用则是隐藏的。可见的应用称为前台应用，而隐藏的则称为后台应用。一个应用在后台运行多长时间时有严格限制的，后续会介绍。当使用iOS应用时，用户可能被其他事情打断－比如电话来电，这时用户正在交互的应用就会被切换。从技术角度来看，应用依然在前台运行，只是非活动状态。如果用户接听电话，电话应用变成了运行在前端，而之前使用的程序就切换到后台运行。还有其他途径使得应用变成非活动状态，比如用户下拉通知中心，打开任务切换器，或者执行其他操作。当应用进入了非活动状态，可能时它退出的信号，所以最好做一些保存的工作。iOS应用生命周期和OS X的也几乎一致。当应用加载时，检查Info.plist 文件，查找可运行文件并加载，于是应用开始执行代码，取出资源文件等。应用加载完毕后，接着接收到applicationDidFinishLaunching: withOptions: 方法。这也和OS X的类似，不过会有一个额外的参数－dictionary，包含了应用为何和怎样加载的信息。通常，用户触摸应用图标就可以启动应用，也可以由其他应用启动，比如一个应用传递文件到另一个应用。可选参数dictionary 包含了描述应用在什么情况下启动应用。和OS X一样，iOS应用也会接收到applicationWillResignActive: 和applicationDidBecomeActive: 消息（有一点不同，消息里的参数时NSNotification 兑对象，而iOS 则是UIApplicaton）。当用户终止运行OS X 应用时，我们直到，应用会接收到applicationWillTerminate: 消息。iOS4 之前也是这么做的，之后，引入了多任务，iOS应用的生命周期就被改变了。iOS 多任务iOS 应用在后台运行，但只能在非常有限的条件下。因为比起OS X 设备，iOS 设备的CPU，内存空间和电池都非常苛刻。一台MacBook Pro，在运行全部的软件－比如文字处理，浏览器等等，可预期续航7个小时。相反，一台iPhone 4S，在用wifi 上网一般可续航8小时。除此外，MacBook pro 有8GB的内存，而iPhone5s 仅有1G。因此，没空间一次装下那么多应用，iOS 需强制一些应用可运行在后台一起持续的时间。如果应用退出了（比如，用户按下home键或打开另一个应用），应用就被挂起－其实并未退出，但停止执行代码，内存也上锁了。当应用恢复时，只需简单地恢复即可。这就是说应用依然保留在内存，但不再消耗系统的资源，比如cpu和定位。不过，内存依然会变少，因此当另一个应用需要更多内存时，应用就悄无声息地终止了。需要注意的是，应用挂起时不执行任何代码，就算被终止了也未必通知用户，因此应用切换至后台时需要提前保存重要的数据。当应用切换到后台运行时，会接收到消息，挂起和唤醒时则不会，这时可以用如下方法：-(void)applicationDidEnterBackground:(UIApplication *)application; -(void)applicationWillEnterForground:(UIApplication *)application; 前者会在应用切换到后台时立即调用，之后，应用进入挂起状态，这时需要保存某些数据，因为期间应用可能会被终止。后者在应用再次回到屏幕之前被调用，此时应用可以重置状态再次运行。上面提到，如果一个前台应用需要更多内存时，挂起的应用可能将被终止。作为开发者，你可以通过减少应用使用的内存降低这种情况发生的机率－释放占内存大的对象，不加载图片等等。任何应用都可以请求在后台运行一段较短的时间，但不能超过10分钟，期间，应用可以完成一些耗时较长的处理－比如写文件到磁盘，完成下载，或者其他耗时操作。10分钟快结束时，应用需要通知系统你处理完毕，或应用将会终止（不是挂起而是终止－完全从内存中消失）。切换至后台运行时，你可以这么做：-(void)applicationDidEnterBackground:(UIApplication *)application { background = [applicaton beginBackgroundTaskWithExpirationHandler:^{ // Stop performing the task in the background(stop calculations, etc) // This expiration handler block is optional, but recommanded!] // Then, tell the system that the task is complete. [application endBackgroundTask: backgroundTask]; backgroundTask = UIBackgroundTaskInvalid; }]; // Start running a block in the background to do the work. dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFALUT, 0), ^{ // Start doing the background work: write, calculate, etc. // Once the work is done, tell the system // that the task is complete. [application endBackgroundTask: backgroundTask]; backgroundTask = UIBackgroundTaskInvalid; }); } 在iOS 7 ，系统不会保证后台任务一次性执行完设定的时间，而是分成多个时间片执行，以便改善电池的寿命。另外，iOS 7里，有两种途径运行后台任务：background fetching 和 background notificationsBackground fetching 是为需要周期性更新的应用设计，比如天气应用或者像Twitter等社交网络应用。通过开启 Background fetching，应用可以在后台得到唤醒并在后台接收更新信息以便用户把应用切换到前台时可以立即使用更新的信息。要使用Background fetching，需要做如下工作：在Project Navigator栏，打开Capabilities页，在Background Modes 里启用Background Fetch 在代码中，需要调用setMinimumBackgroundFetchInterval: 设置应用要更新的周期。如果不设置，系统默认不唤醒应用接收更新。 在实际编码中，你可以这么做：-(void)application: (UIApplication*) application performFetchWithCompletionHandler: (void (^)(UIBackgroundFetchResult))completionHandler { // check for new data to fetch // then tell the system you are finished // what you tell the system changes if you found new data or not // newData is BOOL representing here if there was new data fetched or not if (newData) completionHandler(UIBackgroundFetchResultNewData); else completionHandler(UIBackgroundFetchReslutNoData); } Background notifications 允许应用在后台接收和处理通知信息。即时通信应用使用Background notifications 以便应用在后台自动接收到对话的更新或提醒应用有新的内容可以在接收。Background notifications 其实和background fetching 的操作方式比较相似，两者都需要一些相似的步骤，在第十七章会详细讨论应用如何处理通知，到时你的应用还需要启用远程消息通知。启动远程通知，可在project -&gt; capabilities tab -&gt; Background Modes 勾选 Remote notifacations。同 background fetch 类似，应用任何时候接收到通知消息都可以调用方法处理。捕获通知消息的方法如下：- (void)application: (UIApplication* )application didReceiveRemoteNotification: (NSDictionary* )userInfo fetchCompletionHandler: (void (^)(UIBackgroundFetchResult result))handler 上述方法和background fetch 主要不同的是 userInfo 参数，它是一个包含通知消息数据的字典。另外还有其他在后台运行较长时间的情况，它们适用于特殊的应用：播放音频的应用可以在后台运行任意长时间，直到用户切换至其他播放应用。比如，网络播客应用Pandora 应用可以一直播放，直到用户开始用其他音乐软件播放音乐。追踪用户位置的应用。IP 语音应用（VoIP），比如Skype，允许周期性检查和服务的连接，但不允许无限长时间运行，除非激活了语音通信。总而言之，如果你要开发一个iOS应用，想要运行你的应用只能寄望于用于直接使用你的应用。一旦用户未使用，应用就会直接停止。应用沙盒OS X 和 iOS 实现一系列特性为用户改善整体使用的安全性。其中一个特性就是应用沙盒，一个规定应用可做什么的工具。存在于沙盒中的应用，可能不允许访问沙盒之外的任何资源（硬件，用户数据等等）沙盒在某些情况对于Mac应用是可选的，但对iOS 应用则是强制性的。沙盒通过禁止应用操作苹果公司或用户认为不允许的行为来提高系统的安全性，这对改善应用的安全性尤为重要，因为黑客通常使用软件的漏洞进行入侵。比如怀有恶意的人通过入侵adobe的Acrobat Reader 和 微软的 ie6 来危机用户的系统（这两款软件允许安装第三方插件，收集个人数据等等）。为解决安全问题，沙盒在内核层面限制应用访问用户数据，连接网络，访问诸如相机，麦克风等硬件。即使软件有漏洞，入侵者也无法返回用户的数据，因为应用不允许绕过沙盒。在iOS应用商店下载的软件会自动加入到沙盒中。后续会详细讨论‘应用限制’。而通过Mac 应用商店发布的应用也要求加入到沙盒之中，但自己发布的则没要求。作为开发者，想了解沙盒的影响，参考后面的‘使用沙盒’章节。应用限制上述提及沙盒会对应用的行为有所限制。这种限制在iOS 和 OS X 是差异非常大，因为OS X 一直一来对应用的限制都较少。比如，Mac 的应用可以请求对用户的文件进行读写访问。而iOS 只能处理自身的文件，任何其他文件都不允许打开。iOS 应用限制当设备安装了iOS应用，它就会放到一个规定的文件目录中，结构如下：Documents 存储所有属于应用的文件 Library 存储配置信息 Caches 存储缓存文件，如果系统需要释放内存，可以删除这些文件。 Preference 存储偏爱设置 tmp 存储临时文件，文件会被周期性删除。 Application.app 应用包 iOS 应用不许访问超出自己范围的文件。这样可以禁止应用读取隐私数据（比如通话记录）或修改系统文件。这些严格的限制进使用iOS，Mac 限制相对较宽。Mac 应用限制Mac 的限制仅使用在应用商店发布的应用。当你想将应用加入到沙盒，XCode 有一系列选项供选择，即应用享有所谓的权利。下面是Mac 应用适用的权利：文件系统 你可以决定应用对文件系统的读写权限。你也可以控制应用是否需要用下载文件的目录。 网络 你可以决定应用是否允许传出连接或接收传入连接。 硬件 你可以决定应用是否允许访问内置摄像头和麦克风，USB 和打印机 应用通信 你可以决定应用是否允许使用地址薄或日历数据，以及用户位置信息。 音乐、影片和图片目录 你可以决定应用是否允许使用用户的音乐，图片或影片，可对这西恩目录分别设置权限。 私有API在苹果应用商店发布的应用都需要强制满足一条限制，即应用只能通过苹果公布的类和方法和系统交互。当然，苹果自身会在很多场景使用自用的类和方法。比如iOS设备锁屏的代码，苹果并没有公布给开发者。苹果在审核应用是，会扫描所提交的应用。之前是人工进行，后面都是自动的了。一旦你的应用因使用私有api备具，你就必须移除并重新提交。如果上架的应用存在使用私有api的情况，苹果就直接下架应用。很明显，苹果绝不喜欢开发者使用非官方公布的API。这是因为苹果认为官方公布的API 较为安全和少bug，而且得到官网的维护，较为稳定。而并未公布的api，从某方面来说，可能处于正在开发阶段，或者可能越界访问系统某部分。","categories":[{"name":"学习","slug":"学习","permalink":"https://sucaizi.github.io/categories/学习/"}],"tags":[{"name":"object-c","slug":"object-c","permalink":"https://sucaizi.github.io/tags/object-c/"}]},{"title":"object-c 第三章","slug":"object-c-learning-3","date":"2018-02-11T11:45:25.000Z","updated":"2018-02-11T11:52:20.571Z","comments":true,"path":"2018/02/11/object-c-learning-3/","link":"","permalink":"https://sucaizi.github.io/2018/02/11/object-c-learning-3/","excerpt":"","text":"第三章 框架框架是构成支持所有Objective-C 开发的库的基础。其中包括提供了对诸如字符串，数组，字典，其他通用对象及其适配的方法的支持。框架比Cocoa库处于更低的抽象层次。Cocoa库和UIKit套件关心的应用程序，视图以及用户输入，而框架则关注组织数据的底层任务。在本章中，你将学习框架提供的一些重点类，以及了解Cocoa 和 Cocoa Touch 所依赖的设计模式。可变和不可变对象框架里面几乎所有存储数据的对象都分成两种：可变和不可变。可变对象可在对象创建后被修改，不可变对象则不能。例如，NSArray类，它把对象存储成一个列表，但你不能往里添加，删除，替换对象。如果你想改变它的内容，则需要使用NSMutableArray类。为什么有可变和不可变对象呢？两个理由：如果一个对象是不可变的，说明它所在内存是不能被修改的，因此更有效率。如果你传递了一个不可变对象给另一个对象，可以明保证这个对象永远不能被其他对象修改。你可以为一个已有对象创建其不可变的版本。（反之亦然－你可以创建其可变的版本）例如，通过NSArray 创建 NSutableArray（后续章节会更详细介绍）：// here, &apos;someArray&apos; is an NSArray NSMutableArray* mutableArray = [NSMutableArray arrayWithArray: someArray]; 可变和不可变对象都有各自的用处。大多数情况，编写Mac 和 iOS 应用时用到的是不可变对象。Cocoa常把这些对象作为参数传递，保证类似传递NSArray对象给另一个方法时，不会修改其内容。如果你是java开发者，可能对这种从语言级别区分可变和不可变对象会感到一丝陌生，因为java里习惯使用可变对象。不过随着使用时间变长，你会发现这种区分很有用。字符串简单来说，字符串就是一块文本信息。Objective-C应用处理到文本的地方，基本都会用到NSString，以后你会慢慢熟悉NSString的。由于字符串可存储文本，所以常用于存储我们所写的自然语言（一般用unicode编码）。字符串的创建字符串用NSString 类表示，使Objective-C 对待字符串像其他对象一样。你可以这样创建一个空字符串：NSString* aString = [[NSString alloc] init]; 不推荐这样做，因为NSString 类是不可变的，所以上面创建的空字符串不能被修改。其他的创建方法，比如通过加载文件内容创建，或在代码提供内容来创建，会更有用。Objective-C 使用字符串是非常普遍的，故此提供了一种快速创建方法：NSString* aString = @&quot;Hello, World!&quot;; 注意双引号前面的‘@’ 符号，它告诉编译器创建的是NSString对象而不是C标准的字符串（不属于Objective-C 对象）。因为NSString 是符合Objective-C 标准的对象，所以它可以几首消息，并和应用中其他对象通信。比如，你可以获取新字符串又多少个字符：NSInteger sizeofString = [@&quot;Hello, world!&quot; length]; 用这种语法定义的字符串对象称为文本型字符串。字符串的使用字符串对象提供良好的扩展性和内置大量的方法。大多数情况，字符串有两种用途：处理自然语言和文件路径。这意味NSString 提供大量的方法用于处理这些数据。NSString 创建的三种方法：使用文本，如：@“this example”。由其它数据加载，如文件由已存在的字符串。由文本创建字符串的语法：NSString* constantString = @&quot;Text of the string&quot;; 这种创建的字符串对象，可以直接添加到数组和字典里，后续详细介绍。大小写和路径由于字符要处理自然语言，所以提供一些使用的方法用做转换处理。如大小写转换：NSString* originalString = @&quot;This is An Example&quot;; // &quot;THIS IS AN EXAMPLE&quot; NSString* uppercase = [originalString uppercaseString] // &quot;this is an example&quot; NSString* lowerCaseString = [originalString lowercaseString]; // &quot;This Is An Example&quot; NSString* capitalizedString = [originalString capitalizedString]; 注意，调用上述方法不会改变原字符串，因为它是不可变的；相反，凡涉及处理字符串内容的方法，都会返回一个新字符串对象。查找子符在使用字符串时，有时需要提取子串，例如从“hello world” 中的hello。为了提取子串，可以指定从原字符串的某位置开始直到结尾或从开头到指定位置结束进行查找。也可以在指定的范围内的字符进行查找。想得到一个字符串前5个字符，可以：NSString* startSubstring = [originalString substringToIndex: 5]; // &quot;This &quot; 想得到一个字符串从第5个位置往后的所有字符，可以：NSString* endSubstring = [originalString substringFromIndex: 5]; // &quot;is An EXAMPLE&quot; 想得到某范围内的字符，首先要创建一个 NSRange 的结构体，它定义了范围值。比如，指定从第3个字符开始长度为5的字串，可以：NSRange theRange = NSMakeRange(2, 5); NSRange 有两个变量：位置和长度。位置是从0开始，所以上面的定义需要从2开始。一旦定义好了NSRange，就可以这样获取子串：NSRange theRange = NSMakeRange(2, 5); NSString* subString = [originalString substringWithRange: theRange]; //&quot;is is&quot; 比较字符串字符串比较是常用的操作，不过，不能像下面的代码这样做：// firstString contains &quot;one&quot; and secondString is another object, // also containing &quot;one&quot; if (firstString == secondString){ // do something } 因为 == 操作符只是比较两个变量的指针，实际上检查两个变量在内存位置是否一样，通常结果是否定的。正确的做法是使用 isEqualToString: 方法：if ([firstString isEqualToString: secondString]){ // do something } 当两个字符串内容完全相同，方法返回True，否则False。这个方法大小写敏感。搜索字符串除了检查两个字符串是否一样，你还可以获取字符串所包含更多信息。在Cocoa，你可以查找字符串是否包含特定的子串，或者对比两个字符串看看他们如何排序。查找子串，还是使用rangeOfString 系列方法。调用这些方法，如果子串找到，会返回NSRange，否则，返回的NSRange 中的位置变量是一个NSNotFound常量。例如：NSString* sourceString = @&quot;Four score and seven ago&quot;; NSRange range = [sourceString rangeOfString: @&quot;seven&quot;]; if(range.location == NSNotFound){ // the string was not found } else { // the string was found; &apos;range&apos; variable contains info on where it is } 搜索子串还可以限制范围，或提供可选参数。比如：可以在搜索子串时忽略大小写：NSString* sourceString = @&quot;Four score and seven years ago&quot;; NSRange range = [sourceString rangeOfString: &quot;SEVEN&quot; options: NSCaseInsensitiveSearch]; 数组简而言之，数组是对象的列表。它按序存储对象，允许你一次引用一个或全部对象。数组是Cocoa 里重要的容器类之一，因为它可以在内存允许的情况下存储任意多的对象。任何时候一个方法需要使用一个或多个对象，NSArray几乎都可以用于存储它们。和NSString一样，NSArray是不可变的－－一旦被创建，就不能新加或移除其中的对象。所以，创建NSArray时，需要提供要存储的对象。有多种方法可以实现，比如：使用其他数组的元素来创建。只要是Objective－C 对象，都可以存储在数组，这些对象不需要是相同的类型－－可以将NSString对象和NSView对象存储在同一数组。数组也可以存储其他数组，因为NSArray 本身也是对象。类似NSString的对象，创建NSArray对象也是特别的：NSArray* myArray = @[@&quot;one&quot;, @&quot;two&quot;, @&quot;three&quot;]; 这样就创建了一个新的，不可变的，且包含NSString对象的数组。要从数组中获取某对象，语法是：NSString* oneString = myArray[0]; NSString* twoString = myArray[1]; 数组需要注意的地方：数组从0开始计数，对应第一个对象，其他依此类推。如果使用无效的下标，会导致异常或崩溃。比如，一个有3个对象的数组，你想取下标为3的对象，就会导致异常（下标3对应第4个对象）。iOS5 以下的版本不支持直接访问数组元素的，你需要使用较为啰嗦的方法objectAtIndex: ，如下：NSString* oneString = [myArray objectAtIndex: 0]; 这个方法兼容iOS 7， 所以如果你的代码要兼容其他版本，就可以用这个方法。同样地，你也可以通过count 属性获取数组元素的个数。int count = myArray.count; // count now equals 3 由于NSArray 是对象，所以和其他对象一样可以接收消息。比如，要获知某对象在数组的下标可发送indexOfObject: 方法，如果不存在，方法就返回一个特殊值 NSNotFound：NSArray* myArray = @[@&quot;one&quot;, @&quot;two&quot;, @&quot;three&quot;]; int index = [myArray indexOfObject: @&quot;two&quot;]; // should be equal to 1 if (index == NSNotFound){ NSLog(@&quot;Couldn&apos;t find the object!&quot;); } 若要从其他数组创建一个新数组，可以使用subArrayWithRange: 方法，它需要一个NSRange 参数。新数组里面的对象不会复制过来–即两个数组共同引用这些对象，所以其中一个数组修改了某个对象的属性，必然影响另一个。如果你想把对象拷贝过来，你可以发送copy 消息，它会返回对象一个副本。但不是所有对象都支持拷贝，需要对象实现NSCopying 协议。 下面是一个例子：NSArray* myArray = @[@&quot;one&quot;, @&quot;two&quot;, @&quot;three&quot;]; NSRange subArrayRange = NSMakeRange(1,2); NSArray* subArray = [myArray subArrayWithRange: subArrayRange]; // subArray now contains &quot;two&quot;, &quot;three&quot; 快速列举对于一个容器，有时需要访问它里面的每一个对象，Objective-C 有个特性叫快速列举，允许你快速高效遍历容器的对象。遍历数组对象，你需要这样做：NSArray* myArray = @[@&quot;one&quot;, @&quot;two&quot;, @&quot;three&quot;]; for(NSString* string in myArray){ // this code repeated 3 times, one for each item in the array } 编译器会自动产生低开销的代码遍历容器每一个项。可变数组之前讨论的都是不可变数组NSArray，不过有时想要对数组的元素进行增删改，要怎么做呢？使用NSMutableArray 类即可。NSMutableArray 是NSArray 的子类，所以NSArray能做的，NSMutableArray 也能做到，同样，以NSArray 为参数的方法，可以把NSMutableArray 作为实参传递过去（类的向上转型）通过addObject: 和 insertObject: atIndex: 方法，可以往NSMutableArray 添加对象。前者将新的对象添加到数组的结尾，而后者则把对象插入指定的位置：NSMutableArray* myArray = [NSMutalbeArray arrayWithArray: @[@&quot;One&quot;, &quot;Two&quot;]] // Add &quot;Three&quot; to the end [myArray addObject: @&quot;Three&quot;]; // Add &quot;Zero&quot; to the start [myArray InsertObject: @&quot;Zero&quot; atIndex: 0]; 删除对象，则对应用removeObject: 和removeObjectAtIndex: 方法：NSMutableArray* myArray = [NSMutableArray arrayWithArray: @[@&quot;One&quot;, @&quot;Two&quot;, @&quot;Three&quot;]]; [myArray removeObject: @&quot;One&quot;]; // remove &quot;One&quot; [myArray removeObjectAtIndex: 1]; // remove &quot;Three&quot;, the second item in the array at this point // The array now contains just &quot;Two&quot; 注意，removeObject: 方法会把相同的对象实例全部删除，比如，如果字符串对象@“One” 在数组中出现两次，调用方法时，两个都会被删除。 替换数组中的对象，可以使用replaceObjectAtIndex: withObject: 方法，这个方法需要传递位置和要替换的对象：NSMutableArray* myArray = [NSMutableArray arrayWithArray: @[@&quot;One&quot;, @&quot;Two&quot;, @&quot;Three&quot;]]; [myArray replaceObjectAtIndex: 1 withObject: @&quot;Bananas&quot;]; // myArray is now &quot;One&quot;, &quot;Bananas&quot;, &quot;Three&quot; 也可以直接给可变数组赋值来替换对象：myArray[0] = @&quot;Null&quot;; 提示：只有可变数组才能这么做，不可变数组则不可以。你也不能用这种方法新增和删除对象，只能用于替换数组中一个已经存在的对象。 字典数组只是简单地存储对象的列表，字典较之更为复杂。字典可通过键值（凡支持拷贝的对象都可以作为键值，通常用NSString）映射来存储对象。你可以将字典看作一个表。比如你想存储联系人的信息，就可以用字典表示：key value ---------------------- Name Cave Johnson Company Aperture Science Likes Science Dislikes Lemons 当你想找到联系人的公司信息，通过Company 这个键值找到对应的值 Aperture Science。NSDictionary 和表的工作原理是一样的，而存储对象则和NSArray类似，不同的是多了个键值。当创建NSDictionary 对象时，需要提供键值和要存储的对象，否则不能创建。创建语法如下：NSDictionary* translationDictionary = @{ @“greeting”: @&quot;Hello&quot;, @&quot;farewell&quot;: @&quot;Goodbye&quot; }; 取字典存储对象：NSDictionary* translationDictionary = @{@&quot;greeting&quot;: @&quot;Hello&quot;}; NSString* greeting = translationDictionary[@“greeting”]; 如果对象没找到，则返回nil。字典也可以用快速列举，只需要遍历字典每一个键值。要得到对应对象值，可以用objectForKey: 方法:// Here, aDictionary is an NSDictionary for(NSString* key in aDictionary){ NSObject* theValue = aDictionary[key]; // do something with theValue } 和NSArrays 一样，NSDictionary 也是不可变的，如果要创建可变字典，使用NSMutableDictionary 类，它是NSDictionary 子类，允许新增和删除字典存储的对象。设置字典的值，可以使用和设置数组值的相同方法。插入对象时，需要要键值对应。如果对象已经存在，则会被替换。NSMutableDictionary* aDictionary = @{}; aDictionary[@&quot;greeting&quot;] = @&quot;Hello&quot;; aDictionary[@&quot;farewell&quot;] = @&quot;Goodbye&quot;; NSValue 和NSNumber诸如NSArray 和 NSDictionary等容器类只能存储Objective-C 对象。不过Objective－C里并不是所有的东西都是对象，比如整型和布尔型的值，再如之前讨论的NSRange，都不是对象，因此也就不能存储在数组和字典中。为了解决这个问题，Cocoa 使用一些类来将非对象的值转换称对象进行存储，而这些对象，可以被存储在容器里。NSValue 用于存储多种非对象类型值。NSNumber 只处理和数字相关的，它继承自NSValue。由数字创建NSNumber 对象，只需在数字前使用‘@’，编译器自动推断数字的类型（double， float, character, boolean等）：NSNumber* theNumber = @123; 若要获得存储的数值，可以：int myValue = [theNumber intValue]; NSNumber 实例对象，可以添加到任何容器类的对象：// &apos;numbers&apos; is an NSMutableArray [numbers addObject: theNumber]; NSNumber 还可以通过表达式赋值：int a = 100; NSNumber* number = @(a + 1); // &apos;number&apos; contains 101 NSData当你开发程序时，通常要处理一系列数据。大多数情况，这些数据是从磁盘加载并需要用于对象，或者准备把数据写到磁盘。比如，你加载了一张图片到内存，在内存的角度，图片只是一些字节，在使用这图片前，你必须把这些数据转换称UIIMage对象。NSData被设计成数据的容器。它由字节构成，并且对字节的类型不做任何假设。无论你操作的是文件或者操作从网络加载的信息，接收后的信息都转换成NSData对象，然后再转换成其他对象。NSData 是不可变对象，同样的，也有可变的，即NSMutableDAta。NSMutableData 在不能一次性加载所有字节的情况下比较有用，比如下载文件。从文件和URL 加载数据。大多数情况都会通过磁盘加载文件或URL来创建NSData对象，或者把其他对象转换成NSData对象，这样就能把数据写到磁盘，更多的细节后续会讲到。从磁盘加载文件，你首先要有文件路径。你也可以通过URL来加载文件。例如加载一个文本文件到NSData对象，可以这样：// Assuming that there is a text file at /Examples/Test.txt: NSString* fielPath = @&quot;/Examples/Test.txt&quot;; NSData* loadedData = [NSData dataWithContentsOfFile: filePath]; 因为NSData 对象只能存储数据，接收字节以及写数据到磁盘而不能做其他事情，所以有很多类都设计了处理NSData对象的方法。比如，把NSData对象转换成NSString，可以使用NSString的initWithData: encoding: 方法，参数分别为NSData 和 NSStringEncoding（指定了字节的解码方式）：NSString* loadedString = [[NSString alloc] initWithData: loadedData encoding: NSUTF8StringEncoding]; 提示：上述方法加载字符串不是最高效的方式，只是为了说明NSData 的用法，更好的方法是stringWithContentsOfFile: encoding: error: , 一步到位。 你可以把NSData 对象写入磁盘，使用的方法是 writeToFile: atomically: 。方法需要提供写入路径和一个是否是原子操作的布尔值。如果这个布尔值为YES，NSData先把字节写到临时文件，然后把文件移到指定路径。如果是NO，直接写入目标文件。原子操作会使写入非常慢，因为文件系统需要做移动文件等额外工作，不过这样可以避免程序退出或中途崩溃带来的问题。序列化和反序列化当你用到自己所设计的类的对象时，若能把这些对象存储在磁盘并且在需要时再加载到内存是非常有用的。这就是所谓的序列化和反序列化。通过序列化，你可以将任何对象转换成NSData对象。一旦转换成NSData，你就可以像之前所说的进行读写磁盘。将一个NSData对象还原则称为反序列化。要使用序列化，类必须实现NSCoding协议。序列化就是为相关对象编码成可写入的字节。反序列化则为读入的字节进行解码并重建对象。NSCoding协议有两个主要的方法构成：encodeWithCoder:initWithCoder:任何时候需要为类序列化时，可调用encodeWithCoder: 方法，它要传递NSKeyedArchiver 对象作为参数，用于为对象编码。当从磁盘加载对象时，可调用initWithCoder: 方法，对象就可以根据encodeCoder: 方法序列化后的对象重建自己。这个方法要传递NSKeyedUnarchiver 对象作为参数，用于恢复所存数据。当加载一个对象时，需调用initWithCoder: 方法而不是init方法意味着initWithCoder必须也要实现init方法所实现的逻辑。NSKeyedArchiver 对象的工作原理跟一个可变字典比较类似－使用encodeObject: forKey: 方法并需要传递键值和对象两个参数(相关方法还有 encodeInteger: forKey: 和encodeFloat: forKey:)。方法返回的对象可被序列化以及能够存储到磁盘。下面是实现encodeWithCoder: 方法的例子：-(void) encodeWithCoder: (NSKeyedArchiver*) aCoder{ // Store a string (or any other Objective-C object that supports coding) [aCoder encodeObject: myuStringVariable forKey: @&quot;myString&quot;]; // Store a number [aCoder encodeInteger: myIntegerVariable forKey: @&quot;anInteger&quot;]; } 对应initWithCoder: 方法的实现：- (id) iniWithCoder: (NSkeyedUnarchiver*) aDecoder { self = [super init]; myStringVariable = [aDecoder decodeObjectForKey: @&quot;myString&quot;]; myIntegerVariable = [aDecoder decodeObjectForKey: @&quot;anInteger&quot;]; return self; } 提示： 如果试图反序列化一个不存在的对象，解码器会抛出异常并且导致程序会崩溃。 大部分Cocoa对象都支持序列化和反序列化－比如支持序列化的有 NSArray, NSData和NSDictionary。其他对象是否支持序列化，可以查看类的文档确认是否实现了NSCoding协议。把一个对象转换成可用NSData, 可以这样做：// myObject is an object that // conforms to NSCoding NSData* object storedData = [NSKeyedArchiver archivedDataWithRootObject: myObject]; // storedData can now be written to a file 反过来，则需：// loadedData is NSData loaded from somewhere, and SomeObject is // a class that conforms to NSCoding SomeObject* myObject = [NSKeyedUnarchiver unarchiveObjectWithData: loadedData]; 设计模式Cocoa 是由一系列设计模式构建而成的。下面将介绍三个主要的设计模式，分别为：模型－视图－控制器模式(MVC)，delegation模式(委托模式)以及键－值观察者模式（key-value observing)。模型－视图－控制器模式这个模式是Cocoa最重要的模式，它将对象按职责分成三类：模型，视图，控制器。模型是包含数据的对象或者协调存储、管理和分发数据的对象。简单的模型对象可以是NSString，而更复杂的可以是整个数据库－它们的目的都是存储数据或者向其他对象提供数据。模型关心的是管理如何存储数据，而对其他对象如何处理这些数据则毫不关心。视图负责直接和用户交互，它给用户提供信息和接收用户输入。视图只负责展示数据而不管理数据并在和用户交互时负责通知其他对象。控制器是模型和视图之间的媒介，并且包含了应用的大量业务逻辑－即定义程序是什么和如何响应用户输入的逻辑。控制器至少需要负责从模型接收数据，并将数据提供给数据。它也会在用户和视图交互时负责向模型提供信息。为了更好说明这个模式，就拿编辑器程序举个例子，比如，编辑器程序从磁盘加载文本文件并把文本内容展示给用户，用户修改了文本内容并且保存修改到磁盘。我们可以将这个程序分成模型，视图和控制器对象：模型对象负责从磁盘加载数据和将数据写回磁盘以及负责把文本以NSString方式提供给任何需要的对象。视图对象则负责要求某对象提供NSString类型数据并且展示给用户以及负责接收来自用户的输入。无论何时，只要用户有输入，编辑器会通知某对象文本的变更，同样，用户需要保存更改时，编辑器也能通知到某对象。控制器对象则负责委托模型对象从磁盘加载文件，并将文本传递给视图对象。当文本有更改时，控制器就接收到更新消息。最后，用户要求保存更改会通过视图通知到控制器，这时，控制器会再次委托模型去实际执行把文件写回到磁盘的工作。通过这样区分职责，修改起程序来就变得更容易了。比如，开发者决定下一个版本的程序支持保存文件到互联网，此时只需修改模型，控制器和视图只需保持不变。通过清晰定义对象的职责，在维护时修改起来就比较容易。比如，如果开发者决定添加拼写检查功能，应该修改控制器的代码，因为控制器跟如何展示文本和如何存储文本没有关系。本章讲到的一些主要类如NSData，NSArray和NSDictionary，都可以作为模型。因为它们负责存储数据和向其他类展示信息。NSKeyedArchiver则可作控制器，因为它接收信息并且有处理信息的逻辑。NSButton 和UiTextField 则可作为视图的例子，因为它们仅仅是给用户展示信息。委托模式委托模式是指对象将某些职责委托给别的对象去完成。例如，UIApplication对象，它表示iOS的应用实例。当应用转到后台运行时，需要清楚什么是应该发生的。好多语言处理这用问题时用到的子类化－比如C++，会为UIApplication类定义一个空方法applicationDidEnterBackground,然后开发者需创建UIApplication 的子类，在覆盖applicationDidEnterBackground方法。不过，这种方法特别勉强并且会导致额外的问题－增加了代码的复杂行，也说明如果你想覆盖两个类的方法时，你需要创建两个独立的子类。Objective-C则是基于运行时确定对象，无论另一个对象是否能够响应消息来解决这个问题。一个对象想要另一个对象知道将要发生什么或已经发生了什么，可存储一个对象引用。这个被引用的对象则是委托对象。当事件发生时，它会检查委托的对象是否实现了匹配事件的方法－对于UIApplication类的委托对象，例如，检查委托对象是否实现了applicationEnterBackground方法。如果实现了，该方法则被调用。一个对象可同时作为多个对象的委托。正是因为这种松耦合，一个对象作为多个对象的委托的可能的。比如，某个对象可以是一个声音回放对象和一个图片对象的委托，当声音回放完成和相机捕获完图像后，都能接收到通知。委托里用到的具体方法通常在协议中列出。比如，如果你的对象想要作为AVAudioPlayer对象的委托，则它需要实现AVAudioPlayerDelegate 协议。KVO大多数MVC的实现都依赖控制器及时提供有模型到视图的更新，反之亦然。另一种方式是周期性检查模型和询问模型是否有变更，如果有，然后就向视图提供信息。不过，如果模型不是经常变更，OS X和iOS应用多数情况下模型就不怎么变更，这种方法就很低效了。为了迅速响应，故此Cocoa 实现了所谓的KVO模式。在这个模式中，对象可能注册到其他对象成为观察者。当被观察者发生变更时，就会通知到那些观察者。在分离视图和模块对象中，KVO起到重要作用。更多细节，后续章节会讨论。","categories":[{"name":"学习","slug":"学习","permalink":"https://sucaizi.github.io/categories/学习/"}],"tags":[{"name":"object-c","slug":"object-c","permalink":"https://sucaizi.github.io/tags/object-c/"}]},{"title":"object-c 第二章","slug":"object-c-learning-2","date":"2018-02-11T11:44:41.000Z","updated":"2018-02-11T11:52:20.567Z","comments":true,"path":"2018/02/11/object-c-learning-2/","link":"","permalink":"https://sucaizi.github.io/2018/02/11/object-c-learning-2/","excerpt":"","text":"第二章 Objective-C 与面向对象Objective-C 是一种面向对象的语言。本章带你了解面向对象的含义、Objective-C 如何实现面向对象，以及如何用Objective-C程序实现对象。毫无疑问，面向对象编程是新鲜事物，19世纪80年代开始流行。它保留了大多数共通的编程规范，而且特别适用开发公开某类接口给用户的应用，因为人们习惯就他们所见所接触的对象来思考。Objective-C 使用一种非常独特的方式去实现所谓的面向对象。这带来了一系列的好处，让开发者以较少的代价去理解关于面向对象如何工作的细节以及CoCoa 对你代码的期待。###面向对象编程在任何平台开发任何应用，你都会将代码组织成不同的部分，每一个部分负责程序不同的功能块。即程序每一个任务的逻辑应该避免相互耦合。比如，通过网络和数据库交互的代码就不应该和展示结果给用户的代码混在一起。相反，你应该把代码分成数据库处理层和数据展示层。如果这两层需要交互，那么你就应该清晰地定义接口。这样做使你的代码更易写，易维护和易调试的，代码也容易模块化，因为在不影响程序其他部分的情况下，添加代码（或替换）就变得很直接。除了根据目的分离逻辑外，程序的数据也应该分离。比如，用于展示信息的相关数据（例如字体，颜色，屏幕的位置）不能被负责和数据库交互的代码所修改。另外，你的逻辑应该能够在假设所要处理的数据不会被程序其他部分修改的前提下正常工作。面向对象语言通过引进对象的概念推崇和强制这种分离。###对象对象是由数据块和定义在数据块的操作组成的。只有对象内部的代码才能修改数据，但对象之间可以通过共享数据进行通信。这种隐藏数据的方式称为封装，并且可确保改变一个对象的数据仅能通过对象的提供的函数进行。同一个对象的多个副本能够同一时间存在。每个副本称为对象的一个实例。创建实例的模版则称为类。当你编写面向对象的代码时，你要编写类，然后通过类创建一个或多个实例。一个对象里面的数据称为实例变量，而其函数则称为方法。在大多数面向对象的语言里，一个方法既可能定义成实例方法，也可能是类方法。Objective-C 里所谓的类方法，通常用于创建类的实例。比如，类NSData中一个叫dataWithContentsOfFile：的类方法，可以加载文件并返回NSData对象。###继承面向对象语言允许通过另一个类定义子类。子类和父类相同，但可以添加额外的方法和实例变量。子类创建了一个版本更加具体的类。例如，你定义了一个Server 类，用于处理诸如接收网络连接的任务，然后分别创建了FTPServer 和 HttpServer 子类，处理更具体的连接任务。在Objective-C 中，一个类只有一个父类（不同于C++， 支持继承多个父类）。子类可以覆盖父类的方法。即可以编写一个替换父类一个或多个方法的子类–确切地说，使用Cocoa编程的主要工作都涉及到替换某些方法。接口和实现每个对象都有访问域：私有域和公开域。一个类的公开域就是所谓的接口。它列出了其他类所有能够访问的方法（在Objective-C中，没有公开实例变量一说，不过可以用属性代替，虽然两者作用一样，但属性可以更好地控制其他对象访问本对象的数据）一个类私有域就是所谓的类实现。它包含为类编写的代码，也包含了任何属于该类的私有变量。当你使用一个对象，仅仅是使用对象的接口。即每个对象在其他对象能够对本对象数据做什么和本对象函数能够做什么之间是严格区分的。在Objective-C，一个类的接口的声明和实现是分开的，并且放在不同的文件。包含了类接口的文件叫头文件（历史原因才这么叫），而包含了类实现的文件则是实现文件。头文件以.h作为扩展名，实现文件则以.m作为扩展名。Objective-C 的类接口声明类似如下：@interface MyObject : NSObject { [instance variables] } [method declarations] @end @interface一行定义了类的名字，同时指明了其父类。在花括号里面，可以声明实例变量－这是可选的，同样你可以在实现文件里面声明这些变量；参考“类扩展”这节。对应的实现文件类似如下：@implementation MyObject [method implementations] @end 方法方法即类的函数。和其他函数一样，可以带参数和有返回值。之前说过，方法分为实例方法和类方法。实例方法属于一个类的实例，只能访问实例变量。类方法则不能访问实例变量，因为其不属于实例对象。声明方法:- (void) launchPlane; 以上声明了一个不带参数，没有返回值名为launchPlane的方法。方法名前面的 － 表示它是个实例方法，+ 表示类方法。Objective－C比较有趣和独特的一个地方就是，它的方法名是分段写的。举例会比较容易解释，比如，下面是带一个参数的方法：- (void) launchPlane: (NSString*) planeName; 方法里面的参数planeName 是一个指向 NSString 对象的指针。对比下面带两个参数的方法：－(void) launchPlane: (NSString*) planeName fuelCapacity: (int) litresOfFuel; 这个方法带有一个NSString 的指针planeName和一个int 的 litresOfFuel 参数。此时参数名是并入方法名的。调用一个对象的方法的语法同样和其他语言很不同。假设一个planeLauncher 对象调用方法：[planeLauncher launchPlane]; 可以看到，调用方法的对象在方括号的作左边，而方法名则在右边。对多个参数的方法的调用，语法差不多，几乎和声明是一样：[planeLauncher launchPlane: @&quot;Boeing 747-300&quot; fuelCapacity: 183380]; 这种设计让代码从左到右读起来更能体验语句的意义。例如，读一下上面例子（忽略英语语法），你几乎可以当它是一条命令。在@interface 处声明一个类的方法。举例如下：@interface SomeObject : NSObject - (void) launchPlane: (NSSTring *) planeName; - (int) numberOfPlanesInTheAir; @end 消息Objective-C是消息传递语言，很像Ruby。这个特性使它区别于像C++这样使用早期绑定方法再调用的语言。消息传递意味着一个对象接收一个方法调用时，会在运行时查询再决定运行何种代码。相反，C++ 和其他语言在编译期处理。当对象接收到方法调用时，Objective-C会在运行时查询对象所实现的方法列表。如果找到该方法匹配的消息，就运行该方法的代码。否则，就开始递归查找父类的方法列表，直到返回找到或不能查找为止。如果找不到，就抛出异常，程序终止运行。也可以不这样做－－即捕获异常并处理。XCode就是这么做的：如果有异常，Xcode 就提示错误信息，并允许用户忽略或终止程序。这意味着对象可以用它所接收的消息去做一些有意思的事。例如，（to do）。还可以写自己的逻辑处理没有方法匹配的消息的情况（通常用在数据库的处理代码）因为方法声明和实现代码是分离的，Objective-C 比其它编译语言更具动态性。Cocoa 的威力就是来自这种动态性。在日常工作中，方法和消息的区别并不是很重要。不过，越是明白Objective-C其中的工作原理就越好。属性面向对象编程中，一个对象直接访问另一个对象的数据是糟糕的实践。它破坏了封装，使得一个对象的代码依赖一个对象的存储数据。为了访问和改变另一个对象的变量，可以使用setter和getter 实例方法。后者返回变量当前值，前者则改变变量的值。这两个方法命名需要遵守一些约定。例如，有个实例变量 planeName, setter 方法命名为 setPlaneName: 而getter 方法则命名为 planeName.由于实例变量不允许被其他对象直接访问，如果想被其他对象访问，每个实例变量都要包括getter 和 setter 方法。这样就需要手动写大量getter 和 setter 方法。自从2007 年发布了Objective-C 2.0 后，它包含了一些新特性，移除了这种手写方法，同时使得实例变量易于暴露给其他类。当声明一个可以由其他类的实例访问的变量时，可以这么做：@interface SomeClass : NSObject @property (strong, nonatomic) NSObject* myProperty; @end 属性声明在 @interface 之间，关键字为 @property，其后的括号里面则是该属性的特性列表，接着就是属性类型和名字。属性的特性描述属性对其他对象（或编译器）行为，如下：strong 表示属性强引用。参考 “对象表”。一个对象使用 `strong` 和 `weak` 的属性，可以控制被引用的属性是否保留在内存中。 weak 表示属性弱引用。当引用该属性的对象释放时，属性会自动置为nil。 assign 这个属性的setter 方法仅进行简单的赋值，没内存管理。 copy 这个属性的setter 方法会复制所赋对象，创建原对象的副本。 readwrite 这个属性会产生setter 和 getter 方法（默认设置，当覆盖父类的属性时需要显式设置） readonly 属性不会产生setter 方法，使属性对其他类来说只读（所属类依然可以修改）。 nonatomic 改变变量值时，属性的setter 和 getter 方法不会加锁，使之线程安全。 当你声明属性时，编译器自动产生实例变量存储属性值，还有自动产生getter 和 setter 方法。实例名默认和属性命一致。如果想要实例变量有不同的调用，可以在属性前手动添加@synthesize指令：@implementation MyClass @synthesize myProperty = _myCustomVariableName; // the rest of class code goes here @end 可以用 @dynamic 指令告诉编译器不要合成属性和方法。但你需要自己实现 getter 和 setter 方法：@implementation MyClass @dymatic myProperty; - (int) myProperty{ // this is the getter method for this property return 123; } - (void) setMyProperty: (int) newValue { // this is the setter method for this property } @end 协议协议即要求类去实现的方法列表。它用于表示类的某一项具体能力，比如复制能力，序列化和反序列化，或者作为其他类的数据源。声明协议的语法是：@protocol SomeProtocol [method declarations] @end 一个类要实现协议可以这样：@interface SomeObject : NSObject &lt;SomeProtocol&gt; @end SomeObject 类遵从 SomeProtocol 协议。这是和子类继承方法或覆盖某些方法是不一样的。而且，协议里面指定的必选方法是必须由类实现的。Cocoa 使用协议来和从未见过的类协作比较频繁；如果一个类实现了协议，其可保证Cocoa任何任务需要协议实现的方法都能实现。使用对象时，你一般会显式指定对象类型：NSSTring* aString; 不过，有些情况你可能不知道类型。为了确切知道对象是否实现协议，可以使用如下语法：id &lt;SomeProtocol&gt; someObjectConformingToAProtocol; 运行时，someObjectConformingToAProtocol 对象可能时任何类，但一定是实现了协议。类扩展Objectiv-C 的类可以添加额外的实例变量和方法，这适用于自定义类和系统类。所以，像给NSString 这样的系统类添加方法和实例变量也是可能的，一旦进行类扩展，类的所有实例，都会有所添加的方法。你代码的任何地方都可以声明和实现类扩展。需要类扩展的理由的有：你想要为已存在类加入新的行为或逻辑。这种情况很少出现，不过某些情况你需要Cocoa 加入一些功能，比如，你想给NSString 类加入一个置换字母的方法，就可以这么做。你想把自己的类单独分离成组件。这种情况对开发者来说日益普遍，因为它允许你只把公共的实属性和方法放到你的头文件，而在其他任何地方声明私有的属性和方法。类扩展的语法如下：@interface SomeClass(){ [additional instance variables] } [additional instance or class method declarations] @end 看上去很熟悉－几乎和类接口一样。唯一的改变是用（）代替了父类（之所以没有父类是因为类扩展不允许改变父类）添加多少个类扩展是没有限制的。只要在你项目某处的@implementation 块实现了你所添加的方法即可。为了帮你组织多个扩展，可以对它们进行命名处理。即目录，代码首行可以这么写：@interface SomeClass (SomeCategory) 剩下是一样的了–唯一不同的就是那个目录名。类扩展允许你最小程度公开一些东西给其他类。看看下面的例子，头文件是这样的：@interface SomeClass -(void) doSomethingInteresting; // public, other classes can call this method @end 对应的实现文件：@import &quot;SomeClass.h&quot; @interface SomeClass(){ NSString* privateInstanceVariable; // Only visible to this class } // no other class can see this method because it&apos;s not in the header file, and therefore private - (void) doSomethingPrivate; @end @implementation SomeClass [method implemenation for both doSomethingInteresting and doSomethingPrivate] @end 这么一来，你可以保持你头文件的干净同时仍然可以添加你想要的东西。模块模块是一种链接文件和库到工程的新方法。想了解模块如何工作及其带来的好处，就要回看Objective－C 的历史和#import语句了。当你要引入一个文件时，一般需要这么写代码：＃import &quot;someFile.h&quot; 或假如涉及要引入某框架某文件时：＃import &lt;SomeLibrary/SomeFile.h&gt; 因为Objective-C 是C语言的超集，#import 语句是C＃include语句的细化。include 语句非常简单，编译期间会将include 文件里所搜索到所有代码复制过来。因此有时会产生重大问题。例如，试想如果有两个头文件：SomeFileA.h 和 SomeFileB.h;前者包含后者，后者也要包含前者，导致循环引用，得编译器就会混淆。C 程序员不得不写保护性代码避免这种情况的发生。而使用import，则不必担心这种问题或者去写头文件保护性语句了。但是，import 本质还只是复制－黏贴动作，很容易使编译在一大堆小而危险的问题种变慢。（比如所引入的一个文件使你某处声明的代码无效）模块 就是为了解决此类问题。现在不再是 复制－黏贴源代码了，而是按需导入到你代码。使用模块，代码一般比使用 #include 或 #import编译更快，更安全。回到前面导入一个框架某文件的例子：＃import &lt;SomeLibrary/SomeFile.h&gt; 而使用模块，则可以改成这样：@import SomeLibrary; (To Do)内存管理自从电脑面世后，程序员就要面对存储的问题。简单地说，不可能保留每块单独的数据，即你用完了内存，就要记得归还给系统。否则，机器会耗尽内存而无法工作。所以下面就要讲讲Objective-C 的内存管理，它是通过所谓的引用计数器进行的。引用计数器每个对象都会保存其引用其他对象的数目的变量。当创建一个对象时，引用计数的值开始就是1，并且可增可减。当其值为0时，对象就会被释放，归还内存给系统。当一个对象需要保留另一个对象引用时，就会给对象发送 retain消息，此时引用计数增1。当一个对象不在需要保留另一个对象时，会发送 release 消息，引用计数减1.这么做的好处是，内存管理变的相当容易明白，不用受垃圾回收的偶尔减速，也相对安全–而不需小心翼翼跟踪所释放的内存块，当对象不再被引用时，它会自动归还内存。不好的地方是，程序员需要手动完成这些事情。如果你忘记了你要释放的对象（导致内存泄漏，永远不能释放），或者你释放对象的次数多于其引用的次数（释放一个本来就已被释放的对象会导致崩溃，有时不会–或导致不可预料的情况）。自动引用计数器随着OS X Lion(10.7) 和 iOS 5 的发布，苹果公司引入了全新的基于引用计数的机制，目标是让它既有之前的优点兼具的不会有之前的缺点。这种机制称为 自动引用计数器，简称ARC。除了不需要手动调用 retain和release外–编译器自动调用，ARC 和手动引用计数是一样的。编译器内置源码分析器，可以确定一个对象何时何处开始和停止使用另一个对象，基于这些信息，编译期会适时插入 retain和release方法。这样程序员可放心使用内存而不用担心内存泄漏－－实际可以当作一个无缝的垃圾回收。对象图任何内存管理机制都有一个对象保留周期的问题。为了搞明白这个问题，考虑ARC在什么情况下释放内存是值得的。引用计数机制会在对象的引用数为0时才释放对象的内存。ARC通过跟踪一个对象何时引用另一个对象和引用何时结束来管理引用计数的。问题是，当两个或两个以上的对象之间存在相互引用，除此外没被程序其他地方引用，这些对象就无法被app 触及，因为循环引用的对象，根本不会释放内存。解决这个问题，要用到两种引用类型：强引用和弱引用。强引用：可使被引用对象保留在内存。弱引用：虽然仍然指向被引用对象，但不会像强引用那样进行引用计数，即ARC 不会增加引用值。弱引用一个额外的好处是，当被引用对象释放时，会自动置成nil。即弱引用是安全的，因为它不是有效对象就是nil，从不引用未分配的内存。由于Objective-C 允许向对象发送nil 消息，因此不会导致程序无法运行。声明对对象的强引用，可在声明属性时，用strong特性，弱引用则用weak特性。NSObject 生命周期Cocoa 里无论何种类型的对象都遵循一样模式。下面以对象生命周期作为本章的总结。以下方法定义在Cocoa 的根类NSObject。分配内存和初始化对象只有在程序为其分配内存后才能存在。要做到这一点需通过发送alloc 消息给类。alloc 方法只是简单为对象预留内存，并未使对象可用。为了使对象真正工作起来，你必须调用对象指派的初始化方法。所谓的初始化方法是类的设计者明确必须调用的。对NSObject来说，就是init方法。所以，大部分对象一般都这么作：SomeClass* anObject = [[SomeClass alloc]init]; 其他一些对象可能指派不同的初始化方法，或者有多个初始化方法。比如NSString类：NSString* myString = [[NSString alloc] initWithFormat: @&quot;here&apos;s a number: %i&quot;, 123]; NSString* anotherString = [[NSString alloc] initWithData: anNSDataObject encoding: NSUTF8Encoding]; NSString* oneMoreString = [[NSString alloc] initWithContentsOfFile: @&quot;path to a file&quot; encoding: NSUTF8ENCODING error: someErrorPointer]; 以上方法都可以初始化NSString对象，不过是殊途同归。另外，某些类通过类方法包装alloc 和init 方法直接返回对象。这个又称为工厂方法，因为这就像一家为你生产对象的工厂。下面例子就是使用了工厂方法：NSString* myString = [NSString stringWithFormaty:@&quot;here&apos;s a number: %i&quot;, 123]; retain 和 release当运行在引用计数环境下，就会接受到 retain 和 release 消息。这两个方法都是有根类实现并管理。程序员永远不用调用这些方法，尤其在ARC，如果调用了，反而会导致错误。终止和释放内存当然，我们希望所有对象内存都在不需要时得到释放。不过，在对象内存释放前，对象还有最后的机会去执行代码。在终止时，运行对象移除对其他对象的引用，关闭所有打开的文件，并挽手收尾工作。等到对象引用的数目为0时，对象就会发送dealloc方法。这是对象最后要发送的消息，以用于处理最后的工作。调用了dealloc 之后，对象内存随即归还给系统。","categories":[{"name":"学习","slug":"学习","permalink":"https://sucaizi.github.io/categories/学习/"}],"tags":[{"name":"object-c","slug":"object-c","permalink":"https://sucaizi.github.io/tags/object-c/"}]},{"title":"object-c 第一章","slug":"object-c-learning-1","date":"2018-02-11T11:42:16.000Z","updated":"2018-02-11T11:52:20.579Z","comments":true,"path":"2018/02/11/object-c-learning-1/","link":"","permalink":"https://sucaizi.github.io/2018/02/11/object-c-learning-1/","excerpt":"","text":"第一章Cocoa 开发工具使用Cocoa 和 Cocoa Touch 开发应用程序需要使用苹果提供的一系列工具。在本章，将会学习这些工具，包括从哪里获取工具，怎么使用这些工具，这些工具如何一起工作和它们能做些什么。（TODO）","categories":[{"name":"学习","slug":"学习","permalink":"https://sucaizi.github.io/categories/学习/"}],"tags":[{"name":"object-c","slug":"object-c","permalink":"https://sucaizi.github.io/tags/object-c/"}]},{"title":"JavaBean使用总结","slug":"JavaBean使用总结","date":"2016-01-27T14:32:01.000Z","updated":"2018-02-10T09:01:44.585Z","comments":true,"path":"2016/01/27/JavaBean使用总结/","link":"","permalink":"https://sucaizi.github.io/2016/01/27/JavaBean使用总结/","excerpt":"","text":"一、创建JavaBean创建实现Serializable接口的java类提供无参构造函数提供可读写属性二、Jsp访问JavaBean声明要使用的JavaBean：12//scope的值可以是page，request，session或application&lt;jsp:useBean id=&quot;bean&apos;s name&quot; scope=&quot;bean&apos;s scope&quot; typeSpec/&gt;访问属性：读写方法:12getPropertyName()setPropertyName()在声明的主体下使用，比如：1234&lt;jsp:useBean id=&quot;id&quot; class=&quot;bean&apos;s class&quot; scope=&quot;bean&apos;s scope&quot;&gt; &lt;jsp:setProperty name=&quot;bean&apos;s id&quot; property=&quot;property name&quot; value=&quot;value&quot;/&gt; &lt;jsp:getProperty name=&quot;bean&apos;s id&quot; property=&quot;property name&quot;/&gt;&lt;/jsp:useBean&gt;","categories":[{"name":"java","slug":"java","permalink":"https://sucaizi.github.io/categories/java/"}],"tags":[{"name":"java web","slug":"java-web","permalink":"https://sucaizi.github.io/tags/java-web/"}]},{"title":"JSP与服务器交互总结","slug":"JSP与服务器交互","date":"2016-01-25T12:08:11.000Z","updated":"2018-02-10T08:59:21.409Z","comments":true,"path":"2016/01/25/JSP与服务器交互/","link":"","permalink":"https://sucaizi.github.io/2016/01/25/JSP与服务器交互/","excerpt":"","text":"JSP与服务器交互总结一、发起请求HTTP请求信息头格式：1234567accept */*accept-language en-ususer-agent Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; InfoPath.2; MS-RTC LM 8)accept-encoding gzip, deflatehost localhost:8080connection Keep-Alivecache-control no-cache说明：Accept: 指定浏览器或其他客户端可以处理的MIME类型。它的值通常为 image/png 或 image/jpegAccept-Charset: 指定浏览器要使用的字符集。比如 ISO-8859-1Accept-Encoding: 指定编码类型。它的值通常为 gzip 或compressAccept-Language: 指定客户端首选语言，servlet会优先返回以当前语言构成的结果集，如果servlet支持这种语言的话。比如 en，en-us，ru等等Authorization: 在访问受密码保护的网页时识别不同的用户Connection: 表明客户端是否可以处理HTTP持久连接。持久连接允许客户端或浏览器在一个请求中获取多个文件。Keep-Alive 表示启用持久连接Content-Length: 仅适用于POST请求，表示 POST 数据的字节数Cookie: 返回先前发送给浏览器的cookies至服务器Host: 指出原始URL中的主机名和端口号If-Modified-Since: 表明只有当网页在指定的日期被修改后客户端才需要这个网页。 服务器发送304码给客户端，表示没有更新的资源If-Unmodified-Since: 与If-Modified-Since相反， 只有文档在指定日期后仍未被修改过，操作才会成功Referer: 标志着所引用页面的URL。比如，如果你在页面1，然后点了个链接至页面2，那么页面1的URL就会包含在浏览器请求页面2的信息头中User-Agent: 用来区分不同浏览器或客户端发送的请求，并对不同类型的浏览器返回不同的内容JSP请求对象request作用： 代表客户端发起的请求。封装HTTP信息头读写方法：1234567891011121314151617181920212223242526272829Cookie[] getCookies() 返回客户端所有的Cookie的数组Enumeration getAttributeNames() 返回request对象的所有属性名称的集合Enumeration getHeaderNames() 返回所有HTTP头的名称集合Enumeration getParameterNames() 返回请求中所有参数的集合HttpSession getSession() 返回request对应的session对象，如果没有，则创建一个HttpSession getSession(boolean create) 返回request对应的session对象，如果没有并且参数create为true，则返回一个新的session对象Locale getLocale() 返回当前页的Locale对象，可以在response中设置Object getAttribute(String name) 返回名称为name的属性值，如果不存在则返回null。ServletInputStream getInputStream() 返回请求的输入流String getAuthType() 返回认证方案的名称，用来保护servlet，比如 &quot;BASIC&quot; 或者 &quot;SSL&quot; 或 null 如果 JSP没设置保护措施String getCharacterEncoding() 返回request的字符编码集名称String getContentType() 返回request主体的MIME类型，若未知则返回nullString getContextPath() 返回request URI中指明的上下文路径String getHeader(String name) 返回name指定的信息头String getMethod() 返回此request中的HTTP方法，比如 GET,，POST，或PUTString getParameter(String name) 返回此request中name指定的参数，若不存在则返回nullString getPathInfo() 返回任何额外的与此request URL相关的路径String getProtocol() 返回此request所使用的协议名和版本String getQueryString() 返回此 request URL包含的查询字符串String getRemoteAddr() 返回客户端的IP地址String getRemoteHost() 返回客户端的完整名称String getRemoteUser() 返回客户端通过登录认证的用户，若用户未认证则返回nullString getRequestURI() 返回request的URIString getRequestedSessionId() 返回request指定的session IDString getServletPath() 返回所请求的servlet路径String[] getParameterValues(String name) 返回指定名称的参数的所有值，若不存在则返回nullboolean isSecure() 返回request是否使用了加密通道，比如HTTPSint getContentLength() 返回request主体所包含的字节数，若未知的返回-1int getIntHeader(String name) 返回指定名称的request信息头的值int getServerPort() 返回服务器端口号二、响应请求HTTP响应信息：格式：123456789101112HTTP/1.1 200 OKContent-Type: text/htmlHeader2: ......HeaderN: ...(Blank Line)&lt;!doctype ...&gt;&lt;html&gt;&lt;head&gt;...&lt;/head&gt;&lt;body&gt;...&lt;/body&gt;说明：Allow: 指定服务器支持的request方法（GET，POST等等）Cache-Control: 指定响应文档能够被安全缓存的情况。通常取值为 public，private 或no-cache 等等。 Public意味着文档可缓存，Private意味着文档只为单用户服务并且只能使用私有缓存。No-cache 意味着文档不被缓存。Connection: 命令浏览器是否要使用持久的HTTP连接。close值 命令浏览器不使用持久HTTP连接，而keep-alive 意味着使用持久化连接。Content-Disposition: 让浏览器要求用户将响应以给定的名称存储在磁盘中Content-Encoding: 指定传输时页面的编码规则Content-Language: 表述文档所使用的语言，比如en， en-us,，ru等等Content-Length : 表明响应的字节数。只有在浏览器使用持久化 (keep-alive) HTTP 连接时才有用Content-Type: 表明文档使用的MIME类型Expires: 指明啥时候过期并从缓存中移除Last-Modified: 指明文档最后修改时间。客户端可以 缓存文档并且在后续的请求中提供一个 If-Modified-Since请求头Location: 在300秒内，包含所有的有一个状态码的响应地址，浏览器会自动重连然后检索新文档Refresh: 指明浏览器每隔多久请求更新一次页面。* Retry-After: 与503 (Service Unavailable)一起使用来告诉用户多久后请求将会得到响应Set-Cookie : 指明当前页面对应的cookieJSP响应对象response：作用： 代表客户端的响应。封装处理HTTP响应的读写方法：1234567891011121314151617181920212223String encodeRedirectURL(String url) 对sendRedirect()方法使用的URL进行编码String encodeURL(String url) 将URL编码，回传包含Session ID的URLboolean containsHeader(String name) 返回指定的响应头是否存在boolean isCommitted() 返回响应是否已经提交到客户端void addCookie(Cookie cookie) 添加指定的cookie至响应中void addDateHeader(String name, long date) 添加指定名称的响应头和日期值void addHeader(String name, String value) 添加指定名称的响应头和值void addIntHeader(String name, int value) 添加指定名称的响应头和int值void flushBuffer() 将任何缓存中的内容写入客户端void reset() 清除任何缓存中的任何数据，包括状态码和各种响应头void resetBuffer() 清除基本的缓存数据，不包括响应头和状态码void sendError(int sc) 使用指定的状态码向客户端发送一个出错响应，然后清除缓存void sendError(int sc, String msg) 使用指定的状态码和消息向客户端发送一个出错响应void sendRedirect(String location) 使用指定的URL向客户端发送一个临时的间接响应void setBufferSize(int size) 设置响应体的缓存区大小void setCharacterEncoding(String charset) 指定响应的编码集（MIME字符集），例如UTF-8void setContentLength(int len) 指定HTTP servlets中响应的内容的长度，此方法用来设置 HTTP Content-Length 信息头void setContentType(String type) 设置响应的内容的类型，如果响应还未被提交的话void setDateHeader(String name, long date) 使用指定名称和值设置响应头的名称和内容void setHeader(String name, String value) 使用指定名称和值设置响应头的名称和内容void setIntHeader(String name, int value) 使用指定名称和值设置响应头的名称和内容void setLocale(Locale loc) 设置响应的语言环境，如果响应尚未被提交的话void setStatus(int sc) 设置响应的状态码三、过滤器原理： 一个过滤器就是一个Java类，它实现了javax.servlet.Filter 接口，包含以下几个方法：123public void doFilter (ServletRequest, ServletResponse, FilterChain) 每当 request/response要通过过滤链时容器会调用这个方法，因为客户端请求链尾的资源public void init(FilterConfig filterConfig) 容器调用这个方法来表明一个过滤器被安置在服务中public void destroy() 容器调用这个方法来表明一个过滤器正在从服务中移除作用：在请求访问后端资源时拦截它管理从服务器返回给客户端的响应部署：实现Filter接口，定义过滤器。配置 web.xml （tomcat安装路径下的conf目录）映射成url或jsp, 支持多个，按filter的顺序执行，形如：123456789101112&lt;filter&gt; &lt;filter-name&gt;LogFilter&lt;/filter-name&gt; &lt;filter-class&gt;LogFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;test-param&lt;/param-name&gt; &lt;param-value&gt;Initialization Paramter&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;LogFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;分类：认证过滤器数据压缩过滤器加密过滤器触发资源访问事件的过滤器图像转换过滤器登录和验证过滤器MIME类型链过滤器令牌过滤器转换XML内容的XSL/T过滤器四、 其他Session原理： HTTP是无状态协议，服务器无法辨别请求是否来之同一个客户端，为维持客户端与服务器的会话，可用Session 存储这个用户的所有访问信息，jsp是利用servlet的HttpSession接口来实现的。部署：page指令中设置session属性值:1&lt;%@ page session=&quot;false&quot; %&gt;配置web.xml文件：123&lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt;&lt;/session-config&gt;封装读写session常用方法：1234567891011public Object getAttribute(String name) 返回session对象中与指定名称绑定的对象，如果不存在则返回nullpublic Enumeration getAttributeNames() 返回session对象中所有的对象名称public long getCreationTime() 返回session对象被创建的时间， 以毫秒为单位，从1970年1月1号凌晨开始算起public String getId() 返回session对象的IDpublic long getLastAccessedTime() 返回客户端最后访问的时间，以毫秒为单位，从1970年1月1号凌晨开始算起public int getMaxInactiveInterval() 返回最大时间间隔，以秒为单位，servlet 容器将会在这段时间内保持会话打开public void invalidate() 将session无效化，解绑任何与该session绑定的对象public boolean isNew( 返回是否为一个新的客户端，或者客户端是否拒绝加入sessionpublic void removeAttribute(String name) 移除session中指定名称的对象public void setAttribute(String name, Object value) 使用指定的名称和值来产生一个对象并绑定到session中public void setMaxInactiveInterval(int interval) 用来指定时间，以秒为单位，servlet容器将会在这段时间内保持会话有效Cookies原理： 浏览器在本地机中存储用户信息以便下一次发送请求时服务能够利用该信息识别客户或做其他处理。HTTP Cookie 信息头格式：123456HTTP/1.1 200 OKDate: Fri, 04 Feb 2000 21:03:38 GMTServer: Apache/1.3.9 (UNIX) PHP/4.0b3Set-Cookie: name=xyz; expires=Friday, 04-Feb-07 22:03:38 GMT; path=/; domain=tutorialspoint.comConnection: closeContent-Type: text/html操作Cookies：设置：步骤：123456// (1)创建一个Cookie对象： 调用Cookie的构造函数，使用一个cookie名称和值做参数，它们都是字符串,名称和值中都不能包含空格或 [ ] ( ) = , &quot; / ? @ : ;Cookie cookie = new Cookie(&quot;key&quot;,&quot;value&quot;);// (2) 设置有效期：调用setMaxAge()函数表明cookie在多长时间（以秒为单位）内有效。下面的操作将有效期设为了24小时。cookie.setMaxAge(60*60*24); // (3) 将cookie发送至HTTP响应头中：调用response.addCookie()函数来向HTTP响应头中添加cookies。response.addCookie(cookie);方法说明：123456789101112public void setDomain(String pattern) 设置cookie的域名，比如w3cschool.ccpublic String getDomain() 获取cookie的域名，比如w3cschool.ccpublic void setMaxAge(int expiry) 设置cookie有效期，以秒为单位，默认有效期为当前session的存活时间public int getMaxAge() 获取cookie有效期，以秒为单位，默认为-1 ，表明cookie会活到浏览器关闭为止public String getName() 返回 cookie的名称，名称创建后将不能被修改public void setValue(String newValue) 设置 cookie的值public String getValue() 获取cookie的值public void setPath(String uri) 设置cookie 的路径，默认为当前页面目录下的所有URL，还有此目录下的所有子目录public String getPath() 获取cookie 的路径public void setSecure(boolean flag) 指明cookie是否要加密传输public void setComment(String purpose) 设置注释描述 cookie的目的。当浏览器将cookie展现给用户时，注释将会变得非常有用public String getComment() 返回描述cookie目的的注释，若没有则返回null读取：调用request.getCookies()方法来获得一个javax.servlet.http.Cookie对象的数组遍历这个数组，使用getName()方法和getValue()方法来获取每一个cookie的名称和值删除：获取一个已经存在的cookie（request.getCookies()）将cookie的有效期设置为0（cookie.setMaxAge(0)）将这个cookie重新添加进响应头中（response.addCookie(cookie)）","categories":[{"name":"java","slug":"java","permalink":"https://sucaizi.github.io/categories/java/"}],"tags":[{"name":"java web","slug":"java-web","permalink":"https://sucaizi.github.io/tags/java-web/"}]},{"title":"JSP基础总结","slug":"JSP基础总结","date":"2016-01-24T13:52:34.000Z","updated":"2018-02-10T09:01:09.544Z","comments":true,"path":"2016/01/24/JSP基础总结/","link":"","permalink":"https://sucaizi.github.io/2016/01/24/JSP基础总结/","excerpt":"","text":"jsp 基础总结全称：java server pages文件名后缀：.jsp服务端脚本语言一、开发环境设置配置jdk设置tomcat二、运行原理（图片来源网络，侵删！）Web服务器运行JSP来创建网页的步骤：浏览器发送一个HTTP请求给服务器。Web服务器识别出JSP网页的请求，并且将该请求传递给JSP引擎。（通过使用URL或者.jsp文件来完成。）JSP引擎从磁盘中载入JSP文件，然后将它们转化为servlet。这种转化只是简单地将所有模板文本改用println()语句，并且将所有的JSP元素转化成Java代码。JSP引擎将servlet编译成可执行类，并且将原始请求传递给servlet引擎。Web服务器的某组件将会调用servlet引擎，然后载入并执行servlet类。在执行过程中，servlet产生HTML格式的输出并将其内嵌于HTTP response中上交给Web服务器。Web服务器以静态HTML网页的形式将HTTP response返回到您的浏览器中。最终，Web浏览器处理HTTP response中动态产生的HTML网页，就好像在处理静态网页一样。三、生命周期（图片来源网络，侵删！）编译阶段：servlet容器编译servlet源文件，生成servlet类初始化阶段：加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法-jspInit执行阶段：调用与JSP对应的servlet实例的服务方法-_jspService销毁阶段：调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例-jspDestroy四、语法代码片段：12&lt;% code %&gt;&lt;jsp:scriptlet&gt; code &lt;/jsp:scriptlet&gt;声明变量／方法：12&lt;%! declarations; %&gt;&lt;jsp:declarations&gt; declarations &lt;/jsp:declarations&gt;表达式：12&lt;%= expression %&gt;&lt;jsp:expression&gt; expression &lt;/jsp:expression&gt;注释：1&lt;%-- --%&gt;控制流：条件：if … elseswitch … case循环：forwhiledo … while运算符（略）常量：1Boolean, Integer, String, Null, Floating指令：&lt;%@ directive attribute=”value” %&gt;123&lt;%@ page %&gt; 定义业务依赖属性，比如脚本语言，erro页面&lt;%@ include %&gt; 引入其他文件&lt;%@ taglib %&gt; 引入标签库行为：1&lt;jsp:action_name attribute=&quot;value&quot; /&gt;12345678910jsp:include: 用于在当前页面中包含静态或动态资源jsp:useBean: 寻找和初始化一个JavaBean组件 jsp:setProperty: 设置 JavaBean组件的值 jsp:getProperty: 将JavaBean组件的值插入到output中 jsp:forward: 从一个JSP文件向另一个文件传递一个包含用户请 求的request对象 jsp:plugin: 用于在生成的HTML页面中包含Applet和JavaBean对象 jsp:element: 动态创建一个XML元素 jsp:attribute: 定义动态创建的XML元素的属性 jsp:body: 定义动态创建的XML元素的主体 jsp:text: 用于封装模板数据隐含对象：123456789request: HttpServletRequest类的实例 response: HttpServletResponse类的实例 out: PrintWriter类的实例，用于把结果输出至网页上session: HttpSession类的实例application: ServletContext类的实例，与应用上下文有关config: ServletConfig类的实例pageContext: PageContext类的实例，提供对JSP页面所有对象以及命名空间的访问page: 类似于Java类中的this关键字Exception: Exception类的对象，代表发生错误的JSP页面中对应的异常对象异常:Exception, 只在错误页面中使用try … catch调试使用System.out.println()使用java.util.logging.Logger","categories":[{"name":"java","slug":"java","permalink":"https://sucaizi.github.io/categories/java/"}],"tags":[{"name":"java web","slug":"java-web","permalink":"https://sucaizi.github.io/tags/java-web/"}]},{"title":"2016读书清单","slug":"2016读书清单","date":"2016-01-15T13:52:32.000Z","updated":"2018-02-10T09:01:44.574Z","comments":true,"path":"2016/01/15/2016读书清单/","link":"","permalink":"https://sucaizi.github.io/2016/01/15/2016读书清单/","excerpt":"","text":"2016 阅读书单01月《光荣与梦想》1941～1950年美国叙事史status: 完成author: ［美］威廉 曼彻斯特publisher: 中信出版社language: 中文link:cover:《必然》status: 完成author: ［美］凯文 凯利publisher: 中国工信出版集团 电子工业出版社language: 中文link:cover:《设计模式之禅》status: 在读author: 秦小波publisher: 机械工业出版社language: 中文link:cover:《从0到1》status: 完成author: 皮得 蒂尔publisher: 中信出版社language: 中文link:cover:02月《苏东坡传》status: 在读author: 林语堂著 张振玉 译publisher: 湖南文艺出版社language: 中文link:cover:《光荣与梦想》1951～1960年美国叙事史status: 开读author: ［美］威廉 曼彻斯特publisher: 中信出版社language: 中文link:cover:03月《推理的迷宫》status: 在读author: ［美］威廉 庞德斯通publisher: 中信出版社language: 中文link:cover:《经度》status: 完成author: ［美］达娃 索贝尔 肖明波译publisher: 上海人民出版社language: 中文link:cover:《槽边往事》status: 完成author: 和菜头 著publisher: 中信出版社language: 中文link:cover:《囚徒的困境》status: 在读author: 威廉 庞德斯通 著 吴鹤龄 译publisher: 中信出版社language: 中文link:cover:04月《一星一世界》status: 在读author: ［美］达娃 索贝尔 肖明波译publisher: 上海人民出版社language: 中文link:cover:","categories":[{"name":"读书","slug":"读书","permalink":"https://sucaizi.github.io/categories/读书/"}],"tags":[{"name":"读书","slug":"读书","permalink":"https://sucaizi.github.io/tags/读书/"}]},{"title":"读读想想写写","slug":"读读想想写写","date":"2015-12-16T14:52:18.000Z","updated":"2018-02-10T09:01:44.591Z","comments":true,"path":"2015/12/16/读读想想写写/","link":"","permalink":"https://sucaizi.github.io/2015/12/16/读读想想写写/","excerpt":"","text":"关系型数据库弊端：1.对存量数据较大的表，调整表结构非常困难以及不方便。2.ORM 可能使得操作数据方便，但使得修改表结构非常不灵活。3.需要学习一本新的语言来操作数据库。软件并非功能的堆砌：1.一个软件即使包含1000+ 功能，如果没有实际解决用户的问题，是没法留住用户的。2.构建软件，不妨从解决最基础，最核心的问题开始，当一定量用户提出需要增加功能时，才考虑开发新模块。分而治之：1.学会解构复杂的问题，以大化小，以小化了。专注核心功能：1.开发一个app，不要试图解决2个或2个以上的问题，要么单分别做成一个app，要么选一个问题解决。模仿是开发的第一步：1.如果你不擅长某方面，可以从模仿市场上优秀的软件开始，善于实践，才能较好提高自身水平。","categories":[{"name":"思考与总结","slug":"思考与总结","permalink":"https://sucaizi.github.io/categories/思考与总结/"}],"tags":[{"name":"编程有法","slug":"编程有法","permalink":"https://sucaizi.github.io/tags/编程有法/"}]},{"title":"nodejs 最佳实践","slug":"nodejs最佳实践","date":"2015-12-02T14:45:40.000Z","updated":"2018-02-10T09:01:44.588Z","comments":true,"path":"2015/12/02/nodejs最佳实践/","link":"","permalink":"https://sucaizi.github.io/2015/12/02/nodejs最佳实践/","excerpt":"","text":"收集到关于nodejs 最佳实践：最佳实践（一）构建express 应用目录Best practices for Express app structure最佳实践（二）Model层封装Connecting and Working with MongoDB with Node &amp; ExpressHow To Use MySQL With Node &amp; ExpressConnecting and Working with CouchDB with Node &amp; ExpressUsing Redis as Your Main Superfast Persistent Database in Node &amp; Express最佳实践（三）组织controllerOrganizing your app routes with the Express 4 Router最佳实践（四）测试How to test your MongoDB models under Node &amp; ExpressHow To Test Your Express ControllersHow to automate your Node tests with Jenkins and GitHub最佳实践（五）部署和自动化Hosting &amp; Deploying NodeJS Apps on Ubuntu其他","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://sucaizi.github.io/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://sucaizi.github.io/tags/nodejs/"}]},{"title":"2015读书清单","slug":"2015读书清单","date":"2015-11-30T15:56:32.000Z","updated":"2018-02-10T09:01:40.422Z","comments":true,"path":"2015/11/30/2015读书清单/","link":"","permalink":"https://sucaizi.github.io/2015/11/30/2015读书清单/","excerpt":"","text":"2015 阅读书单12月《光荣与梦想》1932～1972年美国叙事史status: 完成author: ［美］威廉 曼彻斯特publisher: 中信出版社language: 中文link:cover:《设计之下》status: 在读author: 搜狐新闻客户段UED团队publisher: 电子工业出版社language: 中文link:cover:","categories":[{"name":"读书","slug":"读书","permalink":"https://sucaizi.github.io/categories/读书/"}],"tags":[{"name":"读书","slug":"读书","permalink":"https://sucaizi.github.io/tags/读书/"}]}]}
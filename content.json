{"meta":{"title":"future's blog","subtitle":null,"description":"Web & Java Developer","author":"future","url":"https://sucaizi.github.io"},"pages":[{"title":"","date":"2018-02-07T14:59:48.456Z","updated":"2018-01-07T14:08:48.478Z","comments":true,"path":"404.html","permalink":"https://sucaizi.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2015-11-29T15:29:07.000Z","updated":"2018-02-11T10:04:15.876Z","comments":false,"path":"about/index.html","permalink":"https://sucaizi.github.io/about/index.html","excerpt":"","text":"hi，我是future，是一名程序员我的经历2007 - 2011 - 计算机本科毕业2011 - 今 - pc web前端开发, java 后端开发我懂些啥…数据库：mysql，oracle语言：delphi，java, js/html/javascript, python,我正在折腾…web: nodejs 妄图成为全栈开发app: object-c 玩点小应用database：mongodb，mysqllanguage: js,html,css,ruby其实我还喜欢…弹吉他，入门级菜鸟，不提了，但仍在坚持学看看小文章，装文艺必备篮球，打得不错xbox游戏编程，码字打算…和女朋友养只肥猫"},{"title":"书单","date":"2018-02-07T15:02:00.598Z","updated":"2018-02-04T14:54:31.000Z","comments":false,"path":"books/index.html","permalink":"https://sucaizi.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-02-11T09:57:06.396Z","updated":"2018-02-11T09:57:06.395Z","comments":false,"path":"categories/index.html","permalink":"https://sucaizi.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-02-07T15:01:37.380Z","updated":"2018-02-04T14:54:31.000Z","comments":true,"path":"links/index.html","permalink":"https://sucaizi.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-02-10T09:22:24.213Z","updated":"2018-02-10T09:22:24.213Z","comments":false,"path":"repository/index.html","permalink":"https://sucaizi.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2015-12-03T14:56:35.000Z","updated":"2018-02-11T10:00:02.720Z","comments":false,"path":"tags/index.html","permalink":"https://sucaizi.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaBean使用总结","slug":"JavaBean使用总结","date":"2016-01-27T14:32:01.000Z","updated":"2018-02-10T09:01:44.585Z","comments":true,"path":"2016/01/27/JavaBean使用总结/","link":"","permalink":"https://sucaizi.github.io/2016/01/27/JavaBean使用总结/","excerpt":"","text":"一、创建JavaBean创建实现Serializable接口的java类提供无参构造函数提供可读写属性二、Jsp访问JavaBean声明要使用的JavaBean：12//scope的值可以是page，request，session或application&lt;jsp:useBean id=&quot;bean&apos;s name&quot; scope=&quot;bean&apos;s scope&quot; typeSpec/&gt;访问属性：读写方法:12getPropertyName()setPropertyName()在声明的主体下使用，比如：1234&lt;jsp:useBean id=&quot;id&quot; class=&quot;bean&apos;s class&quot; scope=&quot;bean&apos;s scope&quot;&gt; &lt;jsp:setProperty name=&quot;bean&apos;s id&quot; property=&quot;property name&quot; value=&quot;value&quot;/&gt; &lt;jsp:getProperty name=&quot;bean&apos;s id&quot; property=&quot;property name&quot;/&gt;&lt;/jsp:useBean&gt;","categories":[{"name":"java","slug":"java","permalink":"https://sucaizi.github.io/categories/java/"}],"tags":[{"name":"java web","slug":"java-web","permalink":"https://sucaizi.github.io/tags/java-web/"}]},{"title":"JSP与服务器交互总结","slug":"JSP与服务器交互","date":"2016-01-25T12:08:11.000Z","updated":"2018-02-10T08:59:21.409Z","comments":true,"path":"2016/01/25/JSP与服务器交互/","link":"","permalink":"https://sucaizi.github.io/2016/01/25/JSP与服务器交互/","excerpt":"","text":"JSP与服务器交互总结一、发起请求HTTP请求信息头格式：1234567accept */*accept-language en-ususer-agent Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; InfoPath.2; MS-RTC LM 8)accept-encoding gzip, deflatehost localhost:8080connection Keep-Alivecache-control no-cache说明：Accept: 指定浏览器或其他客户端可以处理的MIME类型。它的值通常为 image/png 或 image/jpegAccept-Charset: 指定浏览器要使用的字符集。比如 ISO-8859-1Accept-Encoding: 指定编码类型。它的值通常为 gzip 或compressAccept-Language: 指定客户端首选语言，servlet会优先返回以当前语言构成的结果集，如果servlet支持这种语言的话。比如 en，en-us，ru等等Authorization: 在访问受密码保护的网页时识别不同的用户Connection: 表明客户端是否可以处理HTTP持久连接。持久连接允许客户端或浏览器在一个请求中获取多个文件。Keep-Alive 表示启用持久连接Content-Length: 仅适用于POST请求，表示 POST 数据的字节数Cookie: 返回先前发送给浏览器的cookies至服务器Host: 指出原始URL中的主机名和端口号If-Modified-Since: 表明只有当网页在指定的日期被修改后客户端才需要这个网页。 服务器发送304码给客户端，表示没有更新的资源If-Unmodified-Since: 与If-Modified-Since相反， 只有文档在指定日期后仍未被修改过，操作才会成功Referer: 标志着所引用页面的URL。比如，如果你在页面1，然后点了个链接至页面2，那么页面1的URL就会包含在浏览器请求页面2的信息头中User-Agent: 用来区分不同浏览器或客户端发送的请求，并对不同类型的浏览器返回不同的内容JSP请求对象request作用： 代表客户端发起的请求。封装HTTP信息头读写方法：1234567891011121314151617181920212223242526272829Cookie[] getCookies() 返回客户端所有的Cookie的数组Enumeration getAttributeNames() 返回request对象的所有属性名称的集合Enumeration getHeaderNames() 返回所有HTTP头的名称集合Enumeration getParameterNames() 返回请求中所有参数的集合HttpSession getSession() 返回request对应的session对象，如果没有，则创建一个HttpSession getSession(boolean create) 返回request对应的session对象，如果没有并且参数create为true，则返回一个新的session对象Locale getLocale() 返回当前页的Locale对象，可以在response中设置Object getAttribute(String name) 返回名称为name的属性值，如果不存在则返回null。ServletInputStream getInputStream() 返回请求的输入流String getAuthType() 返回认证方案的名称，用来保护servlet，比如 &quot;BASIC&quot; 或者 &quot;SSL&quot; 或 null 如果 JSP没设置保护措施String getCharacterEncoding() 返回request的字符编码集名称String getContentType() 返回request主体的MIME类型，若未知则返回nullString getContextPath() 返回request URI中指明的上下文路径String getHeader(String name) 返回name指定的信息头String getMethod() 返回此request中的HTTP方法，比如 GET,，POST，或PUTString getParameter(String name) 返回此request中name指定的参数，若不存在则返回nullString getPathInfo() 返回任何额外的与此request URL相关的路径String getProtocol() 返回此request所使用的协议名和版本String getQueryString() 返回此 request URL包含的查询字符串String getRemoteAddr() 返回客户端的IP地址String getRemoteHost() 返回客户端的完整名称String getRemoteUser() 返回客户端通过登录认证的用户，若用户未认证则返回nullString getRequestURI() 返回request的URIString getRequestedSessionId() 返回request指定的session IDString getServletPath() 返回所请求的servlet路径String[] getParameterValues(String name) 返回指定名称的参数的所有值，若不存在则返回nullboolean isSecure() 返回request是否使用了加密通道，比如HTTPSint getContentLength() 返回request主体所包含的字节数，若未知的返回-1int getIntHeader(String name) 返回指定名称的request信息头的值int getServerPort() 返回服务器端口号二、响应请求HTTP响应信息：格式：123456789101112HTTP/1.1 200 OKContent-Type: text/htmlHeader2: ......HeaderN: ...(Blank Line)&lt;!doctype ...&gt;&lt;html&gt;&lt;head&gt;...&lt;/head&gt;&lt;body&gt;...&lt;/body&gt;说明：Allow: 指定服务器支持的request方法（GET，POST等等）Cache-Control: 指定响应文档能够被安全缓存的情况。通常取值为 public，private 或no-cache 等等。 Public意味着文档可缓存，Private意味着文档只为单用户服务并且只能使用私有缓存。No-cache 意味着文档不被缓存。Connection: 命令浏览器是否要使用持久的HTTP连接。close值 命令浏览器不使用持久HTTP连接，而keep-alive 意味着使用持久化连接。Content-Disposition: 让浏览器要求用户将响应以给定的名称存储在磁盘中Content-Encoding: 指定传输时页面的编码规则Content-Language: 表述文档所使用的语言，比如en， en-us,，ru等等Content-Length : 表明响应的字节数。只有在浏览器使用持久化 (keep-alive) HTTP 连接时才有用Content-Type: 表明文档使用的MIME类型Expires: 指明啥时候过期并从缓存中移除Last-Modified: 指明文档最后修改时间。客户端可以 缓存文档并且在后续的请求中提供一个 If-Modified-Since请求头Location: 在300秒内，包含所有的有一个状态码的响应地址，浏览器会自动重连然后检索新文档Refresh: 指明浏览器每隔多久请求更新一次页面。* Retry-After: 与503 (Service Unavailable)一起使用来告诉用户多久后请求将会得到响应Set-Cookie : 指明当前页面对应的cookieJSP响应对象response：作用： 代表客户端的响应。封装处理HTTP响应的读写方法：1234567891011121314151617181920212223String encodeRedirectURL(String url) 对sendRedirect()方法使用的URL进行编码String encodeURL(String url) 将URL编码，回传包含Session ID的URLboolean containsHeader(String name) 返回指定的响应头是否存在boolean isCommitted() 返回响应是否已经提交到客户端void addCookie(Cookie cookie) 添加指定的cookie至响应中void addDateHeader(String name, long date) 添加指定名称的响应头和日期值void addHeader(String name, String value) 添加指定名称的响应头和值void addIntHeader(String name, int value) 添加指定名称的响应头和int值void flushBuffer() 将任何缓存中的内容写入客户端void reset() 清除任何缓存中的任何数据，包括状态码和各种响应头void resetBuffer() 清除基本的缓存数据，不包括响应头和状态码void sendError(int sc) 使用指定的状态码向客户端发送一个出错响应，然后清除缓存void sendError(int sc, String msg) 使用指定的状态码和消息向客户端发送一个出错响应void sendRedirect(String location) 使用指定的URL向客户端发送一个临时的间接响应void setBufferSize(int size) 设置响应体的缓存区大小void setCharacterEncoding(String charset) 指定响应的编码集（MIME字符集），例如UTF-8void setContentLength(int len) 指定HTTP servlets中响应的内容的长度，此方法用来设置 HTTP Content-Length 信息头void setContentType(String type) 设置响应的内容的类型，如果响应还未被提交的话void setDateHeader(String name, long date) 使用指定名称和值设置响应头的名称和内容void setHeader(String name, String value) 使用指定名称和值设置响应头的名称和内容void setIntHeader(String name, int value) 使用指定名称和值设置响应头的名称和内容void setLocale(Locale loc) 设置响应的语言环境，如果响应尚未被提交的话void setStatus(int sc) 设置响应的状态码三、过滤器原理： 一个过滤器就是一个Java类，它实现了javax.servlet.Filter 接口，包含以下几个方法：123public void doFilter (ServletRequest, ServletResponse, FilterChain) 每当 request/response要通过过滤链时容器会调用这个方法，因为客户端请求链尾的资源public void init(FilterConfig filterConfig) 容器调用这个方法来表明一个过滤器被安置在服务中public void destroy() 容器调用这个方法来表明一个过滤器正在从服务中移除作用：在请求访问后端资源时拦截它管理从服务器返回给客户端的响应部署：实现Filter接口，定义过滤器。配置 web.xml （tomcat安装路径下的conf目录）映射成url或jsp, 支持多个，按filter的顺序执行，形如：123456789101112&lt;filter&gt; &lt;filter-name&gt;LogFilter&lt;/filter-name&gt; &lt;filter-class&gt;LogFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;test-param&lt;/param-name&gt; &lt;param-value&gt;Initialization Paramter&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;LogFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;分类：认证过滤器数据压缩过滤器加密过滤器触发资源访问事件的过滤器图像转换过滤器登录和验证过滤器MIME类型链过滤器令牌过滤器转换XML内容的XSL/T过滤器四、 其他Session原理： HTTP是无状态协议，服务器无法辨别请求是否来之同一个客户端，为维持客户端与服务器的会话，可用Session 存储这个用户的所有访问信息，jsp是利用servlet的HttpSession接口来实现的。部署：page指令中设置session属性值:1&lt;%@ page session=&quot;false&quot; %&gt;配置web.xml文件：123&lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt;&lt;/session-config&gt;封装读写session常用方法：1234567891011public Object getAttribute(String name) 返回session对象中与指定名称绑定的对象，如果不存在则返回nullpublic Enumeration getAttributeNames() 返回session对象中所有的对象名称public long getCreationTime() 返回session对象被创建的时间， 以毫秒为单位，从1970年1月1号凌晨开始算起public String getId() 返回session对象的IDpublic long getLastAccessedTime() 返回客户端最后访问的时间，以毫秒为单位，从1970年1月1号凌晨开始算起public int getMaxInactiveInterval() 返回最大时间间隔，以秒为单位，servlet 容器将会在这段时间内保持会话打开public void invalidate() 将session无效化，解绑任何与该session绑定的对象public boolean isNew( 返回是否为一个新的客户端，或者客户端是否拒绝加入sessionpublic void removeAttribute(String name) 移除session中指定名称的对象public void setAttribute(String name, Object value) 使用指定的名称和值来产生一个对象并绑定到session中public void setMaxInactiveInterval(int interval) 用来指定时间，以秒为单位，servlet容器将会在这段时间内保持会话有效Cookies原理： 浏览器在本地机中存储用户信息以便下一次发送请求时服务能够利用该信息识别客户或做其他处理。HTTP Cookie 信息头格式：123456HTTP/1.1 200 OKDate: Fri, 04 Feb 2000 21:03:38 GMTServer: Apache/1.3.9 (UNIX) PHP/4.0b3Set-Cookie: name=xyz; expires=Friday, 04-Feb-07 22:03:38 GMT; path=/; domain=tutorialspoint.comConnection: closeContent-Type: text/html操作Cookies：设置：步骤：123456// (1)创建一个Cookie对象： 调用Cookie的构造函数，使用一个cookie名称和值做参数，它们都是字符串,名称和值中都不能包含空格或 [ ] ( ) = , &quot; / ? @ : ;Cookie cookie = new Cookie(&quot;key&quot;,&quot;value&quot;);// (2) 设置有效期：调用setMaxAge()函数表明cookie在多长时间（以秒为单位）内有效。下面的操作将有效期设为了24小时。cookie.setMaxAge(60*60*24); // (3) 将cookie发送至HTTP响应头中：调用response.addCookie()函数来向HTTP响应头中添加cookies。response.addCookie(cookie);方法说明：123456789101112public void setDomain(String pattern) 设置cookie的域名，比如w3cschool.ccpublic String getDomain() 获取cookie的域名，比如w3cschool.ccpublic void setMaxAge(int expiry) 设置cookie有效期，以秒为单位，默认有效期为当前session的存活时间public int getMaxAge() 获取cookie有效期，以秒为单位，默认为-1 ，表明cookie会活到浏览器关闭为止public String getName() 返回 cookie的名称，名称创建后将不能被修改public void setValue(String newValue) 设置 cookie的值public String getValue() 获取cookie的值public void setPath(String uri) 设置cookie 的路径，默认为当前页面目录下的所有URL，还有此目录下的所有子目录public String getPath() 获取cookie 的路径public void setSecure(boolean flag) 指明cookie是否要加密传输public void setComment(String purpose) 设置注释描述 cookie的目的。当浏览器将cookie展现给用户时，注释将会变得非常有用public String getComment() 返回描述cookie目的的注释，若没有则返回null读取：调用request.getCookies()方法来获得一个javax.servlet.http.Cookie对象的数组遍历这个数组，使用getName()方法和getValue()方法来获取每一个cookie的名称和值删除：获取一个已经存在的cookie（request.getCookies()）将cookie的有效期设置为0（cookie.setMaxAge(0)）将这个cookie重新添加进响应头中（response.addCookie(cookie)）","categories":[{"name":"java","slug":"java","permalink":"https://sucaizi.github.io/categories/java/"}],"tags":[{"name":"java web","slug":"java-web","permalink":"https://sucaizi.github.io/tags/java-web/"}]},{"title":"JSP基础总结","slug":"JSP基础总结","date":"2016-01-24T13:52:34.000Z","updated":"2018-02-10T09:01:09.544Z","comments":true,"path":"2016/01/24/JSP基础总结/","link":"","permalink":"https://sucaizi.github.io/2016/01/24/JSP基础总结/","excerpt":"","text":"jsp 基础总结全称：java server pages文件名后缀：.jsp服务端脚本语言一、开发环境设置配置jdk设置tomcat二、运行原理（图片来源网络，侵删！）Web服务器运行JSP来创建网页的步骤：浏览器发送一个HTTP请求给服务器。Web服务器识别出JSP网页的请求，并且将该请求传递给JSP引擎。（通过使用URL或者.jsp文件来完成。）JSP引擎从磁盘中载入JSP文件，然后将它们转化为servlet。这种转化只是简单地将所有模板文本改用println()语句，并且将所有的JSP元素转化成Java代码。JSP引擎将servlet编译成可执行类，并且将原始请求传递给servlet引擎。Web服务器的某组件将会调用servlet引擎，然后载入并执行servlet类。在执行过程中，servlet产生HTML格式的输出并将其内嵌于HTTP response中上交给Web服务器。Web服务器以静态HTML网页的形式将HTTP response返回到您的浏览器中。最终，Web浏览器处理HTTP response中动态产生的HTML网页，就好像在处理静态网页一样。三、生命周期（图片来源网络，侵删！）编译阶段：servlet容器编译servlet源文件，生成servlet类初始化阶段：加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法-jspInit执行阶段：调用与JSP对应的servlet实例的服务方法-_jspService销毁阶段：调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例-jspDestroy四、语法代码片段：12&lt;% code %&gt;&lt;jsp:scriptlet&gt; code &lt;/jsp:scriptlet&gt;声明变量／方法：12&lt;%! declarations; %&gt;&lt;jsp:declarations&gt; declarations &lt;/jsp:declarations&gt;表达式：12&lt;%= expression %&gt;&lt;jsp:expression&gt; expression &lt;/jsp:expression&gt;注释：1&lt;%-- --%&gt;控制流：条件：if … elseswitch … case循环：forwhiledo … while运算符（略）常量：1Boolean, Integer, String, Null, Floating指令：&lt;%@ directive attribute=”value” %&gt;123&lt;%@ page %&gt; 定义业务依赖属性，比如脚本语言，erro页面&lt;%@ include %&gt; 引入其他文件&lt;%@ taglib %&gt; 引入标签库行为：1&lt;jsp:action_name attribute=&quot;value&quot; /&gt;12345678910jsp:include: 用于在当前页面中包含静态或动态资源jsp:useBean: 寻找和初始化一个JavaBean组件 jsp:setProperty: 设置 JavaBean组件的值 jsp:getProperty: 将JavaBean组件的值插入到output中 jsp:forward: 从一个JSP文件向另一个文件传递一个包含用户请 求的request对象 jsp:plugin: 用于在生成的HTML页面中包含Applet和JavaBean对象 jsp:element: 动态创建一个XML元素 jsp:attribute: 定义动态创建的XML元素的属性 jsp:body: 定义动态创建的XML元素的主体 jsp:text: 用于封装模板数据隐含对象：123456789request: HttpServletRequest类的实例 response: HttpServletResponse类的实例 out: PrintWriter类的实例，用于把结果输出至网页上session: HttpSession类的实例application: ServletContext类的实例，与应用上下文有关config: ServletConfig类的实例pageContext: PageContext类的实例，提供对JSP页面所有对象以及命名空间的访问page: 类似于Java类中的this关键字Exception: Exception类的对象，代表发生错误的JSP页面中对应的异常对象异常:Exception, 只在错误页面中使用try … catch调试使用System.out.println()使用java.util.logging.Logger","categories":[{"name":"java","slug":"java","permalink":"https://sucaizi.github.io/categories/java/"}],"tags":[{"name":"java web","slug":"java-web","permalink":"https://sucaizi.github.io/tags/java-web/"}]},{"title":"2016读书清单","slug":"2016读书清单","date":"2016-01-15T13:52:32.000Z","updated":"2018-02-10T09:01:44.574Z","comments":true,"path":"2016/01/15/2016读书清单/","link":"","permalink":"https://sucaizi.github.io/2016/01/15/2016读书清单/","excerpt":"","text":"2016 阅读书单01月《光荣与梦想》1941～1950年美国叙事史status: 完成author: ［美］威廉 曼彻斯特publisher: 中信出版社language: 中文link:cover:《必然》status: 完成author: ［美］凯文 凯利publisher: 中国工信出版集团 电子工业出版社language: 中文link:cover:《设计模式之禅》status: 在读author: 秦小波publisher: 机械工业出版社language: 中文link:cover:《从0到1》status: 完成author: 皮得 蒂尔publisher: 中信出版社language: 中文link:cover:02月《苏东坡传》status: 在读author: 林语堂著 张振玉 译publisher: 湖南文艺出版社language: 中文link:cover:《光荣与梦想》1951～1960年美国叙事史status: 开读author: ［美］威廉 曼彻斯特publisher: 中信出版社language: 中文link:cover:03月《推理的迷宫》status: 在读author: ［美］威廉 庞德斯通publisher: 中信出版社language: 中文link:cover:《经度》status: 完成author: ［美］达娃 索贝尔 肖明波译publisher: 上海人民出版社language: 中文link:cover:《槽边往事》status: 完成author: 和菜头 著publisher: 中信出版社language: 中文link:cover:《囚徒的困境》status: 在读author: 威廉 庞德斯通 著 吴鹤龄 译publisher: 中信出版社language: 中文link:cover:04月《一星一世界》status: 在读author: ［美］达娃 索贝尔 肖明波译publisher: 上海人民出版社language: 中文link:cover:","categories":[{"name":"读书","slug":"读书","permalink":"https://sucaizi.github.io/categories/读书/"}],"tags":[{"name":"读书","slug":"读书","permalink":"https://sucaizi.github.io/tags/读书/"}]},{"title":"读读想想写写","slug":"读读想想写写","date":"2015-12-16T14:52:18.000Z","updated":"2018-02-10T09:01:44.591Z","comments":true,"path":"2015/12/16/读读想想写写/","link":"","permalink":"https://sucaizi.github.io/2015/12/16/读读想想写写/","excerpt":"","text":"关系型数据库弊端：1.对存量数据较大的表，调整表结构非常困难以及不方便。2.ORM 可能使得操作数据方便，但使得修改表结构非常不灵活。3.需要学习一本新的语言来操作数据库。软件并非功能的堆砌：1.一个软件即使包含1000+ 功能，如果没有实际解决用户的问题，是没法留住用户的。2.构建软件，不妨从解决最基础，最核心的问题开始，当一定量用户提出需要增加功能时，才考虑开发新模块。分而治之：1.学会解构复杂的问题，以大化小，以小化了。专注核心功能：1.开发一个app，不要试图解决2个或2个以上的问题，要么单分别做成一个app，要么选一个问题解决。模仿是开发的第一步：1.如果你不擅长某方面，可以从模仿市场上优秀的软件开始，善于实践，才能较好提高自身水平。","categories":[{"name":"思考与总结","slug":"思考与总结","permalink":"https://sucaizi.github.io/categories/思考与总结/"}],"tags":[{"name":"编程有法","slug":"编程有法","permalink":"https://sucaizi.github.io/tags/编程有法/"}]},{"title":"nodejs 最佳实践","slug":"nodejs最佳实践","date":"2015-12-02T14:45:40.000Z","updated":"2018-02-10T09:01:44.588Z","comments":true,"path":"2015/12/02/nodejs最佳实践/","link":"","permalink":"https://sucaizi.github.io/2015/12/02/nodejs最佳实践/","excerpt":"","text":"收集到关于nodejs 最佳实践：最佳实践（一）构建express 应用目录Best practices for Express app structure最佳实践（二）Model层封装Connecting and Working with MongoDB with Node &amp; ExpressHow To Use MySQL With Node &amp; ExpressConnecting and Working with CouchDB with Node &amp; ExpressUsing Redis as Your Main Superfast Persistent Database in Node &amp; Express最佳实践（三）组织controllerOrganizing your app routes with the Express 4 Router最佳实践（四）测试How to test your MongoDB models under Node &amp; ExpressHow To Test Your Express ControllersHow to automate your Node tests with Jenkins and GitHub最佳实践（五）部署和自动化Hosting &amp; Deploying NodeJS Apps on Ubuntu其他","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://sucaizi.github.io/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://sucaizi.github.io/tags/nodejs/"}]},{"title":"2015读书清单","slug":"2015读书清单","date":"2015-11-30T15:56:32.000Z","updated":"2018-02-10T09:01:40.422Z","comments":true,"path":"2015/11/30/2015读书清单/","link":"","permalink":"https://sucaizi.github.io/2015/11/30/2015读书清单/","excerpt":"","text":"2015 阅读书单12月《光荣与梦想》1932～1972年美国叙事史status: 完成author: ［美］威廉 曼彻斯特publisher: 中信出版社language: 中文link:cover:《设计之下》status: 在读author: 搜狐新闻客户段UED团队publisher: 电子工业出版社language: 中文link:cover:","categories":[{"name":"读书","slug":"读书","permalink":"https://sucaizi.github.io/categories/读书/"}],"tags":[{"name":"读书","slug":"读书","permalink":"https://sucaizi.github.io/tags/读书/"}]}]}
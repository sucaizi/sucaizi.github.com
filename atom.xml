<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>future&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sucaizi.github.io/"/>
  <updated>2018-02-10T09:01:44.585Z</updated>
  <id>https://sucaizi.github.io/</id>
  
  <author>
    <name>future</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaBean使用总结</title>
    <link href="https://sucaizi.github.io/2016/01/27/JavaBean%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://sucaizi.github.io/2016/01/27/JavaBean使用总结/</id>
    <published>2016-01-27T14:32:01.000Z</published>
    <updated>2018-02-10T09:01:44.585Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 11 2018 17:51:33 GMT+0800 (CST) --><h3 id="一、创建JavaBean"><a href="#一、创建JavaBean" class="headerlink" title="一、创建JavaBean"></a>一、创建JavaBean</h3><ul><li>创建实现Serializable接口的java类</li><li>提供无参构造函数</li><li>提供可读写属性</li></ul><h3 id="二、Jsp访问JavaBean"><a href="#二、Jsp访问JavaBean" class="headerlink" title="二、Jsp访问JavaBean"></a>二、Jsp访问JavaBean</h3><ul><li><p>声明要使用的JavaBean：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//scope的值可以是page，request，session或application</span><br><span class="line">&lt;jsp:useBean id=&quot;bean&apos;s name&quot; scope=&quot;bean&apos;s scope&quot; typeSpec/&gt;</span><br></pre></td></tr></table></figure></li><li><p>访问属性：</p><ul><li><p>读写方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getPropertyName()</span><br><span class="line">setPropertyName()</span><br></pre></td></tr></table></figure></li><li><p>在声明的主体下使用，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean id=&quot;id&quot; class=&quot;bean&apos;s class&quot; scope=&quot;bean&apos;s scope&quot;&gt;</span><br><span class="line">  &lt;jsp:setProperty name=&quot;bean&apos;s id&quot; property=&quot;property name&quot; value=&quot;value&quot;/&gt;</span><br><span class="line">  &lt;jsp:getProperty name=&quot;bean&apos;s id&quot; property=&quot;property name&quot;/&gt;</span><br><span class="line">&lt;/jsp:useBean&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Feb 11 2018 17:51:33 GMT+0800 (CST) --&gt;&lt;h3 id=&quot;一、创建JavaBean&quot;&gt;&lt;a href=&quot;#一、创建JavaBean&quot; class=&quot;headerlink&quot; title=&quot;一、创建JavaB
      
    
    </summary>
    
      <category term="java" scheme="https://sucaizi.github.io/categories/java/"/>
    
    
      <category term="java web" scheme="https://sucaizi.github.io/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>JSP与服务器交互总结</title>
    <link href="https://sucaizi.github.io/2016/01/25/JSP%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BA%A4%E4%BA%92/"/>
    <id>https://sucaizi.github.io/2016/01/25/JSP与服务器交互/</id>
    <published>2016-01-25T12:08:11.000Z</published>
    <updated>2018-02-10T08:59:21.409Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 11 2018 17:51:33 GMT+0800 (CST) --><h1 id="JSP与服务器交互总结"><a href="#JSP与服务器交互总结" class="headerlink" title="JSP与服务器交互总结"></a>JSP与服务器交互总结</h1><h3 id="一、发起请求"><a href="#一、发起请求" class="headerlink" title="一、发起请求"></a>一、发起请求</h3><ul><li><p>HTTP请求信息头</p><ul><li><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">accept*/*</span><br><span class="line">accept-languageen-us</span><br><span class="line">user-agentMozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; InfoPath.2; MS-RTC LM 8)</span><br><span class="line">accept-encodinggzip, deflate</span><br><span class="line">hostlocalhost:8080</span><br><span class="line">connectionKeep-Alive</span><br><span class="line">cache-controlno-cache</span><br></pre></td></tr></table></figure></li><li><p>说明：</p><ul><li>Accept: 指定浏览器或其他客户端可以处理的MIME类型。它的值通常为 image/png 或 image/jpeg</li><li>Accept-Charset: 指定浏览器要使用的字符集。比如 ISO-8859-1</li><li>Accept-Encoding: 指定编码类型。它的值通常为 gzip 或compress</li><li>Accept-Language: 指定客户端首选语言，servlet会优先返回以当前语言构成的结果集，如果servlet支持这种语言的话。比如 en，en-us，ru等等</li><li>Authorization: 在访问受密码保护的网页时识别不同的用户</li><li>Connection: 表明客户端是否可以处理HTTP持久连接。持久连接允许客户端或浏览器在一个请求中获取多个文件。Keep-Alive 表示启用持久连接</li><li>Content-Length: 仅适用于POST请求，表示 POST 数据的字节数</li><li>Cookie: 返回先前发送给浏览器的cookies至服务器</li><li>Host: 指出原始URL中的主机名和端口号</li><li>If-Modified-Since: 表明只有当网页在指定的日期被修改后客户端才需要这个网页。 服务器发送304码给客户端，表示没有更新的资源</li><li>If-Unmodified-Since: 与If-Modified-Since相反， 只有文档在指定日期后仍未被修改过，操作才会成功</li><li>Referer: 标志着所引用页面的URL。比如，如果你在页面1，然后点了个链接至页面2，那么页面1的URL就会包含在浏览器请求页面2的信息头中</li><li>User-Agent: 用来区分不同浏览器或客户端发送的请求，并对不同类型的浏览器返回不同的内容</li></ul></li></ul></li><li><p>JSP请求对象request</p><ul><li>作用： 代表客户端发起的请求。</li><li><p>封装HTTP信息头读写方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] getCookies() 返回客户端所有的Cookie的数组</span><br><span class="line">Enumeration getAttributeNames() 返回request对象的所有属性名称的集合</span><br><span class="line">Enumeration getHeaderNames() 返回所有HTTP头的名称集合</span><br><span class="line">Enumeration getParameterNames() 返回请求中所有参数的集合</span><br><span class="line">HttpSession getSession() 返回request对应的session对象，如果没有，则创建一个</span><br><span class="line">HttpSession getSession(boolean create) 返回request对应的session对象，如果没有并且参数create为true，则返回一个新的session对象</span><br><span class="line">Locale getLocale() 返回当前页的Locale对象，可以在response中设置Object getAttribute(String name) 返回名称为name的属性值，如果不存在则返回null。</span><br><span class="line">ServletInputStream getInputStream() 返回请求的输入流</span><br><span class="line">String getAuthType() 返回认证方案的名称，用来保护servlet，比如 &quot;BASIC&quot; 或者 &quot;SSL&quot; 或 null 如果 JSP没设置保护措施</span><br><span class="line">String getCharacterEncoding() 返回request的字符编码集名称</span><br><span class="line">String getContentType() 返回request主体的MIME类型，若未知则返回null</span><br><span class="line">String getContextPath() 返回request URI中指明的上下文路径</span><br><span class="line">String getHeader(String name) 返回name指定的信息头</span><br><span class="line">String getMethod() 返回此request中的HTTP方法，比如 GET,，POST，或PUT</span><br><span class="line">String getParameter(String name) 返回此request中name指定的参数，若不存在则返回null</span><br><span class="line">String getPathInfo() 返回任何额外的与此request URL相关的路径</span><br><span class="line">String getProtocol() 返回此request所使用的协议名和版本</span><br><span class="line">String getQueryString() 返回此 request URL包含的查询字符串</span><br><span class="line">String getRemoteAddr() 返回客户端的IP地址</span><br><span class="line">String getRemoteHost() 返回客户端的完整名称</span><br><span class="line">String getRemoteUser() 返回客户端通过登录认证的用户，若用户未认证则返回null</span><br><span class="line">String getRequestURI() 返回request的URI</span><br><span class="line">String getRequestedSessionId() 返回request指定的session ID</span><br><span class="line">String getServletPath() 返回所请求的servlet路径</span><br><span class="line">String[] getParameterValues(String name) 返回指定名称的参数的所有值，若不存在则返回null</span><br><span class="line">boolean isSecure() 返回request是否使用了加密通道，比如HTTPS</span><br><span class="line">int getContentLength() 返回request主体所包含的字节数，若未知的返回-1</span><br><span class="line">int getIntHeader(String name) 返回指定名称的request信息头的值</span><br><span class="line">int getServerPort() 返回服务器端口号</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="二、响应请求"><a href="#二、响应请求" class="headerlink" title="二、响应请求"></a>二、响应请求</h3><ul><li><p>HTTP响应信息：</p><ul><li><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Header2: ...</span><br><span class="line">...</span><br><span class="line">HeaderN: ...</span><br><span class="line">(Blank Line)</span><br><span class="line">&lt;!doctype ...&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;...&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li><li><p>说明：</p><ul><li>Allow: 指定服务器支持的request方法（GET，POST等等）</li><li>Cache-Control: 指定响应文档能够被安全缓存的情况。通常取值为 public，private 或no-cache 等等。 Public意味着文档可缓存，Private意味着文档只为单用户服务并且只能使用私有缓存。No-cache 意味着文档不被缓存。</li><li>Connection: 命令浏览器是否要使用持久的HTTP连接。close值 命令浏览器不使用持久HTTP连接，而keep-alive 意味着使用持久化连接。</li><li>Content-Disposition: 让浏览器要求用户将响应以给定的名称存储在磁盘中</li><li>Content-Encoding: 指定传输时页面的编码规则</li><li>Content-Language: 表述文档所使用的语言，比如en， en-us,，ru等等</li><li>Content-Length : 表明响应的字节数。只有在浏览器使用持久化 (keep-alive) HTTP 连接时才有用</li><li>Content-Type: 表明文档使用的MIME类型</li><li>Expires: 指明啥时候过期并从缓存中移除</li><li>Last-Modified: 指明文档最后修改时间。客户端可以 缓存文档并且在后续的请求中提供一个 If-Modified-Since请求头</li><li>Location: 在300秒内，包含所有的有一个状态码的响应地址，浏览器会自动重连然后检索新文档</li><li>Refresh: 指明浏览器每隔多久请求更新一次页面。* Retry-After: 与503 (Service Unavailable)一起使用来告诉用户多久后请求将会得到响应</li><li>Set-Cookie : 指明当前页面对应的cookie</li></ul></li></ul></li><li><p>JSP响应对象response：</p><ul><li>作用： 代表客户端的响应。</li><li><p>封装处理HTTP响应的读写方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">String encodeRedirectURL(String url) 对sendRedirect()方法使用的URL进行编码</span><br><span class="line">String encodeURL(String url) 将URL编码，回传包含Session ID的URL</span><br><span class="line">boolean containsHeader(String name) 返回指定的响应头是否存在</span><br><span class="line">boolean isCommitted() 返回响应是否已经提交到客户端</span><br><span class="line">void addCookie(Cookie cookie) 添加指定的cookie至响应中</span><br><span class="line">void addDateHeader(String name, long date) 添加指定名称的响应头和日期值</span><br><span class="line">void addHeader(String name, String value) 添加指定名称的响应头和值</span><br><span class="line">void addIntHeader(String name, int value) 添加指定名称的响应头和int值</span><br><span class="line">void flushBuffer() 将任何缓存中的内容写入客户端</span><br><span class="line">void reset() 清除任何缓存中的任何数据，包括状态码和各种响应头</span><br><span class="line">void resetBuffer() 清除基本的缓存数据，不包括响应头和状态码</span><br><span class="line">void sendError(int sc) 使用指定的状态码向客户端发送一个出错响应，然后清除缓存</span><br><span class="line">void sendError(int sc, String msg) 使用指定的状态码和消息向客户端发送一个出错响应</span><br><span class="line">void sendRedirect(String location) 使用指定的URL向客户端发送一个临时的间接响应</span><br><span class="line">void setBufferSize(int size) 设置响应体的缓存区大小</span><br><span class="line">void setCharacterEncoding(String charset) 指定响应的编码集（MIME字符集），例如UTF-8</span><br><span class="line">void setContentLength(int len) 指定HTTP servlets中响应的内容的长度，此方法用来设置 HTTP Content-Length 信息头</span><br><span class="line">void setContentType(String type) 设置响应的内容的类型，如果响应还未被提交的话</span><br><span class="line">void setDateHeader(String name, long date) 使用指定名称和值设置响应头的名称和内容</span><br><span class="line">void setHeader(String name, String value) 使用指定名称和值设置响应头的名称和内容</span><br><span class="line">void setIntHeader(String name, int value) 使用指定名称和值设置响应头的名称和内容</span><br><span class="line">void setLocale(Locale loc) 设置响应的语言环境，如果响应尚未被提交的话</span><br><span class="line">void setStatus(int sc) 设置响应的状态码</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="三、过滤器"><a href="#三、过滤器" class="headerlink" title="三、过滤器"></a>三、过滤器</h3><ul><li><p>原理： 一个过滤器就是一个Java类，它实现了javax.servlet.Filter 接口，包含以下几个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void doFilter (ServletRequest, ServletResponse, FilterChain) 每当 request/response要通过过滤链时容器会调用这个方法，因为客户端请求链尾的资源</span><br><span class="line">public void init(FilterConfig filterConfig) 容器调用这个方法来表明一个过滤器被安置在服务中</span><br><span class="line">public void destroy() 容器调用这个方法来表明一个过滤器正在从服务中移除</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>作用：</p><ul><li>在请求访问后端资源时拦截它</li><li>管理从服务器返回给客户端的响应</li></ul></li><li><p>部署：</p><ul><li>实现Filter接口，定义过滤器。</li><li><p>配置 web.xml （tomcat安装路径下的conf目录）映射成url或jsp, 支持多个，按filter的顺序执行，形如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">  &lt;filter-name&gt;LogFilter&lt;/filter-name&gt;</span><br><span class="line">  &lt;filter-class&gt;LogFilter&lt;/filter-class&gt;</span><br><span class="line">  &lt;init-param&gt;</span><br><span class="line">    &lt;param-name&gt;test-param&lt;/param-name&gt;</span><br><span class="line">    &lt;param-value&gt;Initialization Paramter&lt;/param-value&gt;</span><br><span class="line">  &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">  &lt;filter-name&gt;LogFilter&lt;/filter-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>分类：<ul><li>认证过滤器</li><li>数据压缩过滤器</li><li>加密过滤器</li><li>触发资源访问事件的过滤器</li><li>图像转换过滤器</li><li>登录和验证过滤器</li><li>MIME类型链过滤器</li><li>令牌过滤器</li><li>转换XML内容的XSL/T过滤器</li></ul></li></ul><h3 id="四、-其他"><a href="#四、-其他" class="headerlink" title="四、 其他"></a>四、 其他</h3><ul><li><p>Session</p><ul><li>原理： HTTP是无状态协议，服务器无法辨别请求是否来之同一个客户端，为维持客户端与服务器的会话，可用Session 存储这个用户的所有访问信息，jsp是利用servlet的HttpSession接口来实现的。</li><li><p>部署：</p><ul><li><p>page指令中设置session属性值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page session=&quot;false&quot; %&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置web.xml文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;session-config&gt;</span><br><span class="line">  &lt;session-timeout&gt;15&lt;/session-timeout&gt;</span><br><span class="line">&lt;/session-config&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>封装读写session常用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Object getAttribute(String name) 返回session对象中与指定名称绑定的对象，如果不存在则返回null</span><br><span class="line">public Enumeration getAttributeNames() 返回session对象中所有的对象名称</span><br><span class="line">public long getCreationTime() 返回session对象被创建的时间， 以毫秒为单位，从1970年1月1号凌晨开始算起</span><br><span class="line">public String getId() 返回session对象的ID</span><br><span class="line">public long getLastAccessedTime() 返回客户端最后访问的时间，以毫秒为单位，从1970年1月1号凌晨开始算起</span><br><span class="line">public int getMaxInactiveInterval() 返回最大时间间隔，以秒为单位，servlet 容器将会在这段时间内保持会话打开</span><br><span class="line">public void invalidate() 将session无效化，解绑任何与该session绑定的对象</span><br><span class="line">public boolean isNew( 返回是否为一个新的客户端，或者客户端是否拒绝加入session</span><br><span class="line">public void removeAttribute(String name) 移除session中指定名称的对象</span><br><span class="line">public void setAttribute(String name, Object value) 使用指定的名称和值来产生一个对象并绑定到session中</span><br><span class="line">public void setMaxInactiveInterval(int interval) 用来指定时间，以秒为单位，servlet容器将会在这段时间内保持会话有效</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Cookies</p><ul><li><p>原理： 浏览器在本地机中存储用户信息以便下一次发送请求时服务能够利用该信息识别客户或做其他处理。</p></li><li><p>HTTP Cookie 信息头格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Fri, 04 Feb 2000 21:03:38 GMT</span><br><span class="line">Server: Apache/1.3.9 (UNIX) PHP/4.0b3</span><br><span class="line">Set-Cookie: name=xyz; expires=Friday, 04-Feb-07 22:03:38 GMT; path=/; domain=tutorialspoint.com</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: text/html</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>操作Cookies：</p><ul><li><p>设置：</p><ul><li><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// (1)创建一个Cookie对象： 调用Cookie的构造函数，使用一个cookie名称和值做参数，它们都是字符串,名称和值中都不能包含空格或 [ ] ( ) = , &quot; / ? @ : ;</span><br><span class="line">Cookie cookie = new Cookie(&quot;key&quot;,&quot;value&quot;);</span><br><span class="line">// (2) 设置有效期：调用setMaxAge()函数表明cookie在多长时间（以秒为单位）内有效。下面的操作将有效期设为了24小时。</span><br><span class="line">cookie.setMaxAge(60*60*24); </span><br><span class="line">// (3) 将cookie发送至HTTP响应头中：调用response.addCookie()函数来向HTTP响应头中添加cookies。</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure></li><li><p>方法说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void setDomain(String pattern) 设置cookie的域名，比如w3cschool.cc</span><br><span class="line">public String getDomain() 获取cookie的域名，比如w3cschool.cc</span><br><span class="line">public void setMaxAge(int expiry) 设置cookie有效期，以秒为单位，默认有效期为当前session的存活时间</span><br><span class="line">public int getMaxAge() 获取cookie有效期，以秒为单位，默认为-1 ，表明cookie会活到浏览器关闭为止</span><br><span class="line">public String getName() 返回 cookie的名称，名称创建后将不能被修改</span><br><span class="line">public void setValue(String newValue) 设置 cookie的值</span><br><span class="line">public String getValue() 获取cookie的值</span><br><span class="line">public void setPath(String uri) 设置cookie 的路径，默认为当前页面目录下的所有URL，还有此目录下的所有子目录</span><br><span class="line">public String getPath() 获取cookie 的路径</span><br><span class="line">public void setSecure(boolean flag) 指明cookie是否要加密传输</span><br><span class="line">public void setComment(String purpose) 设置注释描述 cookie的目的。当浏览器将cookie展现给用户时，注释将会变得非常有用</span><br><span class="line">public String getComment() 返回描述cookie目的的注释，若没有则返回null</span><br></pre></td></tr></table></figure></li></ul></li><li><p>读取：</p><ol><li>调用request.getCookies()方法来获得一个javax.servlet.http.Cookie对象的数组</li><li>遍历这个数组，使用getName()方法和getValue()方法来获取每一个cookie的名称和值</li></ol></li><li><p>删除：</p><ol><li>获取一个已经存在的cookie（request.getCookies()）</li><li>将cookie的有效期设置为0（cookie.setMaxAge(0)）</li><li>将这个cookie重新添加进响应头中（response.addCookie(cookie)）</li></ol></li></ul></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Feb 11 2018 17:51:33 GMT+0800 (CST) --&gt;&lt;h1 id=&quot;JSP与服务器交互总结&quot;&gt;&lt;a href=&quot;#JSP与服务器交互总结&quot; class=&quot;headerlink&quot; title=&quot;JSP与服务器交互总结
      
    
    </summary>
    
      <category term="java" scheme="https://sucaizi.github.io/categories/java/"/>
    
    
      <category term="java web" scheme="https://sucaizi.github.io/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>JSP基础总结</title>
    <link href="https://sucaizi.github.io/2016/01/24/JSP%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
    <id>https://sucaizi.github.io/2016/01/24/JSP基础总结/</id>
    <published>2016-01-24T13:52:34.000Z</published>
    <updated>2018-02-10T09:01:09.544Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 11 2018 17:51:33 GMT+0800 (CST) --><h1 id="jsp-基础总结"><a href="#jsp-基础总结" class="headerlink" title="jsp 基础总结"></a>jsp 基础总结</h1><ul><li>全称：java server pages</li><li>文件名后缀：.jsp</li><li>服务端脚本语言</li></ul><h3 id="一、开发环境设置"><a href="#一、开发环境设置" class="headerlink" title="一、开发环境设置"></a>一、开发环境设置</h3><ol><li>配置jdk</li><li>设置tomcat</li></ol><h3 id="二、运行原理"><a href="#二、运行原理" class="headerlink" title="二、运行原理"></a>二、运行原理</h3><p><img src="http://www.runoob.com/wp-content/uploads/2014/01/jsp-processing.jpg" alt="image">（图片来源网络，侵删！）</p><p>Web服务器运行JSP来创建网页的步骤：</p><ol><li>浏览器发送一个HTTP请求给服务器。</li><li>Web服务器识别出JSP网页的请求，并且将该请求传递给JSP引擎。（通过使用URL或者.jsp文件来完成。）</li><li>JSP引擎从磁盘中载入JSP文件，然后将它们转化为servlet。这种转化只是简单地将所有模板文本改用println()语句，并且将所有的JSP元素转化成Java代码。</li><li>JSP引擎将servlet编译成可执行类，并且将原始请求传递给servlet引擎。</li><li>Web服务器的某组件将会调用servlet引擎，然后载入并执行servlet类。在执行过程中，servlet产生HTML格式的输出并将其内嵌于HTTP response中上交给Web服务器。</li><li>Web服务器以静态HTML网页的形式将HTTP response返回到您的浏览器中。</li><li>最终，Web浏览器处理HTTP response中动态产生的HTML网页，就好像在处理静态网页一样。</li></ol><h3 id="三、生命周期"><a href="#三、生命周期" class="headerlink" title="三、生命周期"></a>三、生命周期</h3><p><img src="http://www.runoob.com/wp-content/uploads/2014/01/jsp_life_cycle.jpg" alt="image">（图片来源网络，侵删！）</p><ul><li>编译阶段：servlet容器编译servlet源文件，生成servlet类</li><li>初始化阶段：加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法-jspInit</li><li>执行阶段：调用与JSP对应的servlet实例的服务方法-_jspService</li><li>销毁阶段：调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例-jspDestroy</li></ul><h3 id="四、语法"><a href="#四、语法" class="headerlink" title="四、语法"></a>四、语法</h3><ul><li><p>代码片段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;% code %&gt;</span><br><span class="line">&lt;jsp:scriptlet&gt; code &lt;/jsp:scriptlet&gt;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>声明变量／方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%! declarations; %&gt;</span><br><span class="line">&lt;jsp:declarations&gt; declarations &lt;/jsp:declarations&gt;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%= expression %&gt;</span><br><span class="line">&lt;jsp:expression&gt; expression &lt;/jsp:expression&gt;</span><br></pre></td></tr></table></figure></li><li><p>注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%-- --%&gt;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>控制流：</p><ul><li><p>条件：</p><ul><li>if … else</li><li>switch … case</li></ul></li><li><p>循环：</p><ul><li>for</li><li>while</li><li>do … while</li></ul></li></ul></li><li><p>运算符（略）</p></li><li><p>常量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Boolean, Integer, String, Null, Floating</span><br></pre></td></tr></table></figure></li><li><p>指令：</p><p>&lt;%@ directive attribute=”value” %&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page %&gt; 定义业务依赖属性，比如脚本语言，erro页面</span><br><span class="line">&lt;%@ include %&gt;  引入其他文件</span><br><span class="line">&lt;%@ taglib %&gt;  引入标签库</span><br></pre></td></tr></table></figure></li><li><p>行为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:action_name attribute=&quot;value&quot; /&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jsp:include: 用于在当前页面中包含静态或动态资源</span><br><span class="line">jsp:useBean: 寻找和初始化一个JavaBean组件 </span><br><span class="line">jsp:setProperty: 设置 JavaBean组件的值 </span><br><span class="line">jsp:getProperty: 将JavaBean组件的值插入到output中 </span><br><span class="line">jsp:forward: 从一个JSP文件向另一个文件传递一个包含用户请 求的request对象 </span><br><span class="line">jsp:plugin: 用于在生成的HTML页面中包含Applet和JavaBean对象 </span><br><span class="line">jsp:element: 动态创建一个XML元素 </span><br><span class="line">jsp:attribute: 定义动态创建的XML元素的属性 </span><br><span class="line">jsp:body: 定义动态创建的XML元素的主体 </span><br><span class="line">jsp:text: 用于封装模板数据</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>隐含对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">request: HttpServletRequest类的实例        </span><br><span class="line">response: HttpServletResponse类的实例      </span><br><span class="line">out: PrintWriter类的实例，用于把结果输出至网页上</span><br><span class="line">session: HttpSession类的实例</span><br><span class="line">application: ServletContext类的实例，与应用上下文有关</span><br><span class="line">config: ServletConfig类的实例</span><br><span class="line">pageContext: PageContext类的实例，提供对JSP页面所有对象以及命名空间的访问</span><br><span class="line">page: 类似于Java类中的this关键字</span><br><span class="line">Exception: Exception类的对象，代表发生错误的JSP页面中对应的异常对象</span><br></pre></td></tr></table></figure></li><li><p>异常:</p><ul><li>Exception, 只在错误页面中使用</li><li>try … catch</li></ul></li><li><p>调试</p><ul><li>使用System.out.println()</li><li>使用java.util.logging.Logger</li></ul></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Feb 11 2018 17:51:33 GMT+0800 (CST) --&gt;&lt;h1 id=&quot;jsp-基础总结&quot;&gt;&lt;a href=&quot;#jsp-基础总结&quot; class=&quot;headerlink&quot; title=&quot;jsp 基础总结&quot;&gt;&lt;/a&gt;jsp
      
    
    </summary>
    
      <category term="java" scheme="https://sucaizi.github.io/categories/java/"/>
    
    
      <category term="java web" scheme="https://sucaizi.github.io/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>2016读书清单</title>
    <link href="https://sucaizi.github.io/2016/01/15/2016%E8%AF%BB%E4%B9%A6%E6%B8%85%E5%8D%95/"/>
    <id>https://sucaizi.github.io/2016/01/15/2016读书清单/</id>
    <published>2016-01-15T13:52:32.000Z</published>
    <updated>2018-02-10T09:01:44.574Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 11 2018 17:51:33 GMT+0800 (CST) --><h1 id="2016-阅读书单"><a href="#2016-阅读书单" class="headerlink" title="2016 阅读书单"></a>2016 阅读书单</h1><h2 id="01月"><a href="#01月" class="headerlink" title="01月"></a>01月</h2><h3 id="《光荣与梦想》1941～1950年美国叙事史"><a href="#《光荣与梦想》1941～1950年美国叙事史" class="headerlink" title="《光荣与梦想》1941～1950年美国叙事史"></a>《光荣与梦想》1941～1950年美国叙事史</h3><ul><li>status: 完成</li><li>author: ［美］威廉 曼彻斯特</li><li>publisher: 中信出版社</li><li>language: 中文</li><li>link:</li><li>cover:</li></ul><h3 id="《必然》"><a href="#《必然》" class="headerlink" title="《必然》"></a>《必然》</h3><ul><li>status: 完成</li><li>author: ［美］凯文 凯利</li><li>publisher: 中国工信出版集团 电子工业出版社</li><li>language: 中文</li><li>link:</li><li>cover:</li></ul><h3 id="《设计模式之禅》"><a href="#《设计模式之禅》" class="headerlink" title="《设计模式之禅》"></a>《设计模式之禅》</h3><ul><li>status: 在读</li><li>author: 秦小波</li><li>publisher: 机械工业出版社</li><li>language: 中文</li><li>link:</li><li>cover:</li></ul><h3 id="《从0到1》"><a href="#《从0到1》" class="headerlink" title="《从0到1》"></a>《从0到1》</h3><ul><li>status: 完成</li><li>author: 皮得 蒂尔</li><li>publisher: 中信出版社</li><li>language: 中文</li><li>link:</li><li>cover:</li></ul><h2 id="02月"><a href="#02月" class="headerlink" title="02月"></a>02月</h2><h3 id="《苏东坡传》"><a href="#《苏东坡传》" class="headerlink" title="《苏东坡传》"></a>《苏东坡传》</h3><ul><li>status: 在读</li><li>author: 林语堂著 张振玉 译</li><li>publisher: 湖南文艺出版社</li><li>language: 中文</li><li>link:</li><li>cover:</li></ul><h3 id="《光荣与梦想》1951～1960年美国叙事史"><a href="#《光荣与梦想》1951～1960年美国叙事史" class="headerlink" title="《光荣与梦想》1951～1960年美国叙事史"></a>《光荣与梦想》1951～1960年美国叙事史</h3><ul><li>status: 开读</li><li>author: ［美］威廉 曼彻斯特</li><li>publisher: 中信出版社</li><li>language: 中文</li><li>link:</li><li>cover:</li></ul><h2 id="03月"><a href="#03月" class="headerlink" title="03月"></a>03月</h2><h3 id="《推理的迷宫》"><a href="#《推理的迷宫》" class="headerlink" title="《推理的迷宫》"></a>《推理的迷宫》</h3><ul><li>status: 在读</li><li>author: ［美］威廉 庞德斯通</li><li>publisher: 中信出版社</li><li>language: 中文</li><li>link:</li><li>cover:</li></ul><h3 id="《经度》"><a href="#《经度》" class="headerlink" title="《经度》"></a>《经度》</h3><ul><li>status: 完成</li><li>author: ［美］达娃 索贝尔 肖明波译</li><li>publisher: 上海人民出版社</li><li>language: 中文</li><li>link:</li><li>cover:</li></ul><h3 id="《槽边往事》"><a href="#《槽边往事》" class="headerlink" title="《槽边往事》"></a>《槽边往事》</h3><ul><li>status: 完成</li><li>author: 和菜头 著</li><li>publisher: 中信出版社</li><li>language: 中文</li><li>link:</li><li>cover:</li></ul><h3 id="《囚徒的困境》"><a href="#《囚徒的困境》" class="headerlink" title="《囚徒的困境》"></a>《囚徒的困境》</h3><ul><li>status: 在读</li><li>author: 威廉 庞德斯通 著 吴鹤龄 译</li><li>publisher: 中信出版社</li><li>language: 中文</li><li>link:</li><li>cover:</li></ul><h2 id="04月"><a href="#04月" class="headerlink" title="04月"></a>04月</h2><h3 id="《一星一世界》"><a href="#《一星一世界》" class="headerlink" title="《一星一世界》"></a>《一星一世界》</h3><ul><li>status: 在读</li><li>author: ［美］达娃 索贝尔 肖明波译</li><li>publisher: 上海人民出版社</li><li>language: 中文</li><li>link:</li><li>cover:</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Feb 11 2018 17:51:33 GMT+0800 (CST) --&gt;&lt;h1 id=&quot;2016-阅读书单&quot;&gt;&lt;a href=&quot;#2016-阅读书单&quot; class=&quot;headerlink&quot; title=&quot;2016 阅读书单&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="读书" scheme="https://sucaizi.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读书" scheme="https://sucaizi.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>读读想想写写</title>
    <link href="https://sucaizi.github.io/2015/12/16/%E8%AF%BB%E8%AF%BB%E6%83%B3%E6%83%B3%E5%86%99%E5%86%99/"/>
    <id>https://sucaizi.github.io/2015/12/16/读读想想写写/</id>
    <published>2015-12-16T14:52:18.000Z</published>
    <updated>2018-02-10T09:01:44.591Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 11 2018 17:51:33 GMT+0800 (CST) --><ul><li><p>关系型数据库弊端：</p><p>1.对存量数据较大的表，调整表结构非常困难以及不方便。</p><p>2.ORM 可能使得操作数据方便，但使得修改表结构非常不灵活。</p><p>3.需要学习一本新的语言来操作数据库。</p></li></ul><ul><li><p>软件并非功能的堆砌：</p><p>1.一个软件即使包含1000+ 功能，如果没有实际解决用户的问题，是没法留住用户的。</p><p>2.构建软件，不妨从解决最基础，最核心的问题开始，当一定量用户提出需要增加功能时，才考虑开发新模块。</p></li></ul><ul><li><p>分而治之：</p><p>1.学会解构复杂的问题，以大化小，以小化了。</p></li><li><p>专注核心功能：</p><p>1.开发一个app，不要试图解决2个或2个以上的问题，要么单分别做成一个app，要么选一个问题解决。</p></li><li><p>模仿是开发的第一步：<br>1.如果你不擅长某方面，可以从模仿市场上优秀的软件开始，善于实践，才能较好提高自身水平。</p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Feb 11 2018 17:51:33 GMT+0800 (CST) --&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;关系型数据库弊端：&lt;/p&gt;&lt;p&gt;1.对存量数据较大的表，调整表结构非常困难以及不方便。&lt;/p&gt;&lt;p&gt;2.ORM 可能使得操作数据方便，但使得
      
    
    </summary>
    
      <category term="思考与总结" scheme="https://sucaizi.github.io/categories/%E6%80%9D%E8%80%83%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="编程有法" scheme="https://sucaizi.github.io/tags/%E7%BC%96%E7%A8%8B%E6%9C%89%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>nodejs 最佳实践</title>
    <link href="https://sucaizi.github.io/2015/12/02/nodejs%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://sucaizi.github.io/2015/12/02/nodejs最佳实践/</id>
    <published>2015-12-02T14:45:40.000Z</published>
    <updated>2018-02-10T09:01:44.588Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 11 2018 17:51:33 GMT+0800 (CST) --><p>收集到关于nodejs 最佳实践：</p><ul><li><p>最佳实践（一）构建express 应用目录</p><p><a href="https://www.terlici.com/2014/08/25/best-practices-express-structure.html" target="_blank" rel="noopener">Best practices for Express app structure</a></p></li><li><p>最佳实践（二）Model层封装</p><p><a href="https://www.terlici.com/2015/04/03/mongodb-node-express.html" target="_blank" rel="noopener">Connecting and Working with MongoDB with Node &amp; Express</a></p><p><a href="https://www.terlici.com/2015/08/13/mysql-node-express.html" target="_blank" rel="noopener">How To Use MySQL With Node &amp; Express</a></p><p><a href="https://www.terlici.com/2015/04/28/couchdb-node-express.html" target="_blank" rel="noopener">Connecting and Working with CouchDB with Node &amp; Express</a></p><p><a href="https://www.terlici.com/2015/06/15/redis-node-express.html" target="_blank" rel="noopener">Using Redis as Your Main Superfast Persistent Database in Node &amp; Express</a></p></li><li><p>最佳实践（三）组织controller</p><p><a href="https://www.terlici.com/2014/09/29/express-router.html" target="_blank" rel="noopener">Organizing your app routes with the Express 4 Router</a></p></li><li><p>最佳实践（四）测试</p><p><a href="https://www.terlici.com/2014/09/15/node-testing.html" target="_blank" rel="noopener">How to test your MongoDB models under Node &amp; Express</a></p><p><a href="https://www.terlici.com/2015/09/21/node-express-controller-testing.html" target="_blank" rel="noopener">How To Test Your Express Controllers</a></p><p><a href="https://www.terlici.com/2015/09/29/automated-testing-with-node-express-github-and-jenkins.html" target="_blank" rel="noopener">How to automate your Node tests with Jenkins and GitHub</a></p></li><li><p>最佳实践（五）部署和自动化</p><p><a href="https://www.terlici.com/2015/02/05/hosting-deploying-nodejs.html" target="_blank" rel="noopener">Hosting &amp; Deploying NodeJS Apps on Ubuntu</a></p></li><li><p>其他</p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Feb 11 2018 17:51:33 GMT+0800 (CST) --&gt;&lt;p&gt;收集到关于nodejs 最佳实践：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;最佳实践（一）构建express 应用目录&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://w
      
    
    </summary>
    
      <category term="nodejs" scheme="https://sucaizi.github.io/categories/nodejs/"/>
    
    
      <category term="nodejs" scheme="https://sucaizi.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>2015读书清单</title>
    <link href="https://sucaizi.github.io/2015/11/30/2015%E8%AF%BB%E4%B9%A6%E6%B8%85%E5%8D%95/"/>
    <id>https://sucaizi.github.io/2015/11/30/2015读书清单/</id>
    <published>2015-11-30T15:56:32.000Z</published>
    <updated>2018-02-10T09:01:40.422Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 11 2018 17:51:33 GMT+0800 (CST) --><h1 id="2015-阅读书单"><a href="#2015-阅读书单" class="headerlink" title="2015 阅读书单"></a>2015 阅读书单</h1><h2 id="12月"><a href="#12月" class="headerlink" title="12月"></a>12月</h2><h3 id="《光荣与梦想》1932～1972年美国叙事史"><a href="#《光荣与梦想》1932～1972年美国叙事史" class="headerlink" title="《光荣与梦想》1932～1972年美国叙事史"></a>《光荣与梦想》1932～1972年美国叙事史</h3><ul><li>status: 完成</li><li>author: ［美］威廉 曼彻斯特</li><li>publisher: 中信出版社</li><li>language: 中文</li><li>link:</li><li>cover:</li></ul><h3 id="《设计之下》"><a href="#《设计之下》" class="headerlink" title="《设计之下》"></a>《设计之下》</h3><ul><li>status: 在读</li><li>author: 搜狐新闻客户段UED团队</li><li>publisher: 电子工业出版社</li><li>language: 中文</li><li>link:</li><li>cover:</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Feb 11 2018 17:51:33 GMT+0800 (CST) --&gt;&lt;h1 id=&quot;2015-阅读书单&quot;&gt;&lt;a href=&quot;#2015-阅读书单&quot; class=&quot;headerlink&quot; title=&quot;2015 阅读书单&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="读书" scheme="https://sucaizi.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读书" scheme="https://sucaizi.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
</feed>
